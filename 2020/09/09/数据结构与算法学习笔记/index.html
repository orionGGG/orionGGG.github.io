<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="数据结构绪论">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法学习笔记">
<meta property="og:url" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="MyBlog">
<meta property="og:description" content="数据结构绪论">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%9B%86%E5%90%88%E7%BB%93%E6%9E%84.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%BD%A2%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%B3%E7%B3%BB.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B8%B8%E8%A7%81%E8%A1%A8.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BA%BF%E6%80%A7%E8%A1%A8.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BA%BF%E6%80%A7%E9%A1%BA%E5%BA%8F.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9C%B0%E5%9D%80%E8%AE%A1%E7%AE%97.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A1%BA%E5%BA%8F%E6%8F%92%E5%85%A5.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A1%BA%E5%BA%8F%E5%88%A0%E9%99%A4.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BA%BF%E6%80%A7%E9%A1%BA%E5%BA%8F%E4%BC%98%E7%BC%BA%E7%82%B9.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E9%93%BE%E8%A1%A81.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E9%93%BE%E8%A1%A82.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%B4%E7%BB%93%E7%82%B9%E5%8D%95%E9%93%BE%E8%A1%A8.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%B4%E6%8C%87%E9%92%88%E4%B8%8E%E5%A4%B4%E7%BB%93%E7%82%B9%E5%BC%82%E5%90%8C.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%A9%BA%E9%93%BE%E8%A1%A8.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%97%A0%E5%A4%B4%E7%BB%93%E7%82%B9%E5%8D%95%E9%93%BE%E8%A1%A8.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%B4%E7%BB%93%E7%82%B9%E5%8D%95%E9%93%BE%E8%A1%A8.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%A9%BA%E9%93%BE%E8%A1%A8.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A1%A8%E5%A4%B4%E8%A1%A8%E5%B0%BE%E6%8F%92%E5%85%A5.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%B0%BE%E6%8F%92%E6%B3%95.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%BC%98%E7%BC%BA%E7%82%B9.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%A9%BA%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%9D%9E%E7%A9%BA%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%BF%9B%E6%A0%88%E5%87%BA%E6%A0%88.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%88%E7%9A%84%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%88%E5%9B%BE.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%A4%E6%A0%88%E5%85%B1%E4%BA%AB%E7%A9%BA%E9%97%B4.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%93%BE%E6%A0%88%E7%9A%84%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%93%BE%E6%A0%88%E8%BF%9B%E6%A0%88.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%93%BE%E6%A0%88%E5%87%BA%E6%A0%88.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%98%9F%E5%88%97%E5%9B%BE%E7%A4%BA.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%A5%E9%98%9F%E5%88%97.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BA%E9%98%9F%E5%88%971.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BA%E9%98%9F%E5%88%972.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%98%9F%E5%88%97%E6%BC%94%E7%A4%BA.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%81%87%E6%BA%A2%E5%87%BA.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%971.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%972.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%973.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%93%BE%E9%98%9F%E5%88%971.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%A9%BA%E9%93%BE%E9%98%9F%E5%88%97.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%93%BE%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%93%BE%E9%98%9F%E5%88%97%E5%85%A5%E9%98%9F.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%93%BE%E9%98%9F%E5%88%97%E5%87%BA%E9%98%9F.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A1%BA%E5%BA%8F%E4%B8%B2.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%93%BE%E5%BC%8F%E4%B8%B2.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%91.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E7%82%B9%E5%88%86%E7%B1%BB.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E7%82%B9%E9%97%B4%E5%85%B3%E7%B3%BB.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E7%BB%93%E6%9E%84.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E7%82%B9%E7%BB%93%E6%9E%84%E5%9B%BE1.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E7%82%B9%E7%BB%93%E6%9E%84%E5%9B%BE2.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%BE%E4%BE%8B.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%9112.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%A7%E8%B4%A83.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%A7%E8%B4%A85.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%95%B0%E7%BB%84.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8F%B3%E6%96%9C%E6%A0%91%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%861.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%862.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%863.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%864.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%865.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%861.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%862.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%863.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%864.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%865.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%866.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%861.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C1.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C2.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C3.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B1.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B2.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%91%E7%9A%84%E5%B8%A6%E6%9D%83%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6%E4%B8%BE%E4%BE%8B.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%97%A0%E5%90%91%E5%9B%BE.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9C%89%E5%90%91%E5%9B%BE.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BD%91.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BD%91.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%BF%9E%E9%80%9A%E5%9B%BE.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%BF%9E%E9%80%9A%E5%9B%BE2.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%94%9F%E6%88%90%E6%A0%91.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AE%9E%E4%BE%8B.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AE%9E%E4%BE%8B1.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%9A%84%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%9A%84%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AE%9E%E4%BE%8B.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%82%BB%E6%8E%A5%E8%A1%A81.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%82%BB%E6%8E%A5%E8%A1%A82.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%82%BB%E6%8E%A5%E8%A1%A83.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%99%AE%E9%87%8C%E5%A7%86%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F1.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F2.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F3.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%841.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%BA%90%E7%82%B9.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%841.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%B7%9D%E7%A6%BB%E8%A1%A81.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E4%B8%BE%E4%BE%8B.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91%E4%B8%BE%E4%BE%8B.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B0%8F%E9%A1%B6%E5%A0%86%E4%B8%BE%E4%BE%8B.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F1.jpg">
<meta property="og:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F1.jpg">
<meta property="article:published_time" content="2020-09-08T16:33:13.000Z">
<meta property="article:modified_time" content="2021-02-01T15:18:56.248Z">
<meta property="article:author" content="orion">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%9B%86%E5%90%88%E7%BB%93%E6%9E%84.jpg">

<link rel="canonical" href="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据结构与算法学习笔记 | MyBlog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MyBlog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/suki.jpg">
      <meta itemprop="name" content="orion">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MyBlog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构与算法学习笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-09 00:33:13" itemprop="dateCreated datePublished" datetime="2020-09-09T00:33:13+08:00">2020-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-01 23:18:56" itemprop="dateModified" datetime="2021-02-01T23:18:56+08:00">2021-02-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="数据结构绪论"><a href="#数据结构绪论" class="headerlink" title="数据结构绪论"></a>数据结构绪论</h2><a id="more"></a>
<p><em>数据结构</em>：<br>是相互之间存在一种或多种特定关系的数据元素集合</p>
<h3 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h3><p><strong>数据</strong>：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。<br>数据不仅包括整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。</p>
<p><strong>数据元素</strong>：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。<br>举个例子，在人类中，数据元素就是人(有点像类和对象的关系)</p>
<p><strong>数据项</strong>：一个数据元素可以由若干个数据项组成。<br>数据项是数据不可分割的最小单位。<br>比如人这样的数据元素可以有眼，耳，鼻这些数据项，也可以有姓名，年龄，性别等数据项</p>
<p><strong>数据对象</strong>：是性质相同的数据元素的集合，是数据的子集<br>什么叫性质相同呢，是指数据元素具有相同数量和类型的数据项。比如还是刚才的例子，人都有姓名，生日，性别等数据项</p>
<p><strong>数据结构</strong>：是相互之间存在一种或多种特定关系的数据元素的集合<br>数据元素之间不是独立的，而是存在特定的关系，我们将这些关系称为结构</p>
<h3 id="逻辑结构和物理结构"><a href="#逻辑结构和物理结构" class="headerlink" title="逻辑结构和物理结构"></a>逻辑结构和物理结构</h3><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p><strong>逻辑结构</strong>：是指数据对象中数据元素之间的相互关系</p>
<p><strong>集合结构</strong>：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。各个数据元素是“平等”的。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%9B%86%E5%90%88%E7%BB%93%E6%9E%84.jpg" alt="集合结构"></p>
<p><strong>线性结构</strong>：数据元素之间是一对一的关系</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.jpg" alt="线性结构"></p>
<p><strong>树形结构</strong>：数据元素之间存在一种一对多的关系</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84.jpg" alt="树形结构"></p>
<p><strong>图形结构</strong>：数据元素之间是多对多的关系</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%BD%A2%E7%BB%93%E6%9E%84.png" alt="图形结构"></p>
<h4 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h4><p><strong>物理结构</strong>：是指数据的逻辑结构在计算机中的存储形式</p>
<p><strong>顺序存储结构</strong>：是把数据元素存放在地址连续的存储单元里。其数据间的逻辑关系和物理关系是一致的。<br>说白了就是排队占位。大家都按照顺序排队。比如说数组就是这样的顺序存储结构。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.jpg" alt="顺序存储"></p>
<p><strong>链式存储结构</strong>：是把数据元素存放在任意的存储单元内。这些存储单元可以是连续的，也可以是不连续的。数组元素的存储关系并不能反映其逻辑关系。因此需要用一个指针存放数据元素的地址，这样就能够通过地址找到相关的数据元素的位置。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8.jpg" alt="链式存储"></p>
<p>显然，链式存储灵活多了，数据存在哪里不重要，只要有一个指针存放了相应的地址就能够找到他了。</p>
<p>逻辑结构是面向问题的，而物理结构是面向计算机的，其基本目标就是讲数据及其逻辑关系存储到计算机的内存中。</p>
<h3 id="数据类型和抽象数据类型"><a href="#数据类型和抽象数据类型" class="headerlink" title="数据类型和抽象数据类型"></a>数据类型和抽象数据类型</h3><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p><strong>数据类型</strong>：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称</p>
<p><strong>原子类型</strong>：是不可以再分解的基本类型，包括整型(int)，实型(float)，字符型(char)</p>
<p><strong>结构类型</strong>：由若干个类型组合而成，是可以再分解的。例如，整型数组是由若干整型数据组成的</p>
<p>比如，在C中变量声明int a, b,这就意味着，在给变量a和b赋值是不能超出int的取值范围，变量a和b之间的运算只能是int类型所允许的运算。</p>
<h4 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h4><p><strong>抽象数据类型</strong>：是指一个数学模型及定义在该模型上的一组操作。抽象数据类型的定义金取决于他的一组逻辑特性，而与其在计算机内部如何表示和实现无关。</p>
<p>比如刚才的例子，各个计算机，不管是大型机、小型机、PC、平板、智能手机都拥有“整数”类型，也需要整数间的运算，那么整型其实就是一个抽象数据类型。尽管他在上述产品中的实现方法可能不一样，但由于其定义的数学特性相同、在程序员看来、他们都是相同的。因此，“抽象”的意义在于数据类型的数学抽象特性。</p>
<h3 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h3><p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%B3%E7%B3%BB.jpg" alt="数据关系"></p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84.jpg" alt="结构"></p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p><em>算法</em>：<br>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p>
<h3 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h3><p>算法具有5个基本特性：输入、输出、有穷性、确定性和可行性</p>
<p><strong>输入输出</strong>：<br>　　输入和输出特性比较容易理解，算法具有零个或多个输入。尽管对于绝大多数算法来说，输入参数都是必要的，但对于个别情况，如打印”Hello world!”这样的代码，不需要输入任何参数，因此算法的输入可以是零个。算法至少有一个或多个输出，算法是一定需要输出的，不需要输出，你用这个算法干嘛？输出的形式可以是打印输出，也可以是返回一个或多个值。</p>
<p><strong>有穷性</strong>：<br>　　是指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤都在可以接受的时间内完成。现实中经常会写出死循环的代码，这是不满足有穷性的。当然这里有穷的概念不是纯数学意义的，而是在实际应用当中合理的、可以接受的“有边界”。</p>
<p><strong>确定性</strong>：<br>　　算法的每一步骤都具有确定的含义，不会出现二义性。算法在一定条件下，只有一条执行路径，相同的输入只能有唯一确定的输出结果。算法每个步骤被精确定义而无歧义。</p>
<p><strong>可行性</strong>：<br>　　算法的每一步都必须是可行的，也就是说每一步都能够通过执行有限次数完成。</p>
<h3 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h3><p><strong>正确性</strong>：<br>正确性：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性，能正确反映问题的需求、能够得到问题的正确答案。</p>
<p>但是算法的“正确”通常在用法上有很大差别，大体分为以下四个层次：</p>
<p>1、算法程序没有语法错误。</p>
<p>2、算法程序对于合发的输入数据能够产生满足要求的输出结果，</p>
<p>3、算法程序对于非法的输入数据能够得出满足规格说明的结果。</p>
<p>4、算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。</p>
<p><strong>可读性</strong>：<br>算法设计的另一目的是为了便于阅读、理解和交流。</p>
<p><strong>健壮性</strong>：<br>当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。</p>
<p><strong>时间与存储</strong>：<br>好的算法还应该具备时间效率高和存储量低的特点。</p>
<h3 id="算法效率的度量方法"><a href="#算法效率的度量方法" class="headerlink" title="算法效率的度量方法"></a>算法效率的度量方法</h3><p><strong>事前分析估算方法</strong>：<br>在计算机程序编制前，依据统计方法对算法进行估算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, sum = <span class="number">0</span>, n = <span class="number">0</span>;      执行一次</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)     执行n + <span class="number">1</span>次</span><br><span class="line">&#123;</span><br><span class="line">    sum = sum + <span class="number">1</span>;      执行n次</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%d&quot;</span>, sum);     执行一次</span><br></pre></td></tr></table></figure>

<p>上述算法共执行了2n+3次</p>
<h3 id="函数的渐进增长"><a href="#函数的渐进增长" class="headerlink" title="函数的渐进增长"></a>函数的渐进增长</h3><p>函数的渐进增长：给定连个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的 n &gt; N，f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于g(n)。</p>
<p>渐近增长的比较中，加法常数可以忽略</p>
<p>判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项(最高阶项)的阶数</p>
<p>某个算法，随着 n 的增大，它会越来越优于另一种算法，或者越来越差于另一种算法，这其实就是事前估算方法的理论依据，通过算法时间复杂度来估算算法时间效率</p>
<h3 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h3><p>算法的时间复杂度，也就是算法的时间度量，记作：T(n)=O(f(n))。它表示随问题规模n的怎大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，剪成时间复杂度。其中f(n)是问题规模n的某个函数。</p>
<p>这里用大写O()来体现算法的时间复杂度，我们称之为大O()记法</p>
<p>一般情况下，随着n的增大，T(n)增长最慢的算法为最优算法。</p>
<p>O(1)叫做常数阶<br>O(n)叫做线性阶<br>O(n<sup>2</sup>)叫做平方阶</p>
<p>推导大O阶方法：<br>1、用常数1取代运行时间中的所有加法常数<br>2、在第1步后的运行次数函数中，只保留最高阶<br>3、如果最高阶存在且不为1，则去除与这个项相乘的常数。(就是使得最高阶项系数为1)<br>得到结果</p>
<p><strong>常数阶</strong><br>注意：不管这个常数是多少，我们都记作O(1)，而不是O(3)、O(12)等其他任何数字。</p>
<p><strong>线性阶</strong><br>关键是要分析循环结构的运行情况</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    时间复杂度为O(<span class="number">1</span>)的程序步骤</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码时间复杂度为n</p>
<p><strong>对数阶</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(count &lt; n)</span><br><span class="line">&#123;</span><br><span class="line">    count = count * <span class="number">2</span>;</span><br><span class="line">    时间复杂度为O(<span class="number">1</span>)的程序步骤</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于每次count乘以2之后，就距离n更进一步。也就是说，有多少个2相乘后大于n，则退出循环。有2<sup>x</sup>=n 得到 x=log<sub>2</sub>n。所以这个循环的时间复杂度为O(fogn) 不管底数</p>
<p><strong>平方阶</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j&lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        时间复杂度为O(<span class="number">1</span>)的程序步骤</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于外层的循环，不过是内部这个时间复杂度为O(n)的语句，在循环n次。所以这段代码的时间复杂度为O(n<sup>2</sup>)。<br>如果外循环的循环次数改成了m，时间复杂度就变成了O(m X n)。</p>
<p>所以我们可以总结出，循环的时间复杂度等于循环体的复杂度乘以改循环运行的次数</p>
<p>对于方法调用的时间复杂度也是一样，用循环次数乘以函数的时间复杂度</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B8%B8%E8%A7%81%E8%A1%A8.jpg" alt="常见"></p>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p><strong>线性表</strong>：<br>零个或多个数据元素的有限序列</p>
<h3 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h3><p>线性表，从名字你就可以感觉到，是具有像线一样的性质的表。<br>一个班级的小朋友，一个跟着一个排队，有一个打头，有一个收尾，当中的小朋友每一个都知道他前面一个是谁，也知道他后面是谁，这样如同有一根线把他们串联起来了。就可以称之为线性表。</p>
<p><strong>线性表：零个或多个数据元素的有限序列。</strong></p>
<p><strong>关键点</strong>：<br>1、首先线性表是一个序列。也就是说，元素之间是有顺序的，若元素存在多个，则第一个元素无前驱，最后一个元素无后继，其他每个元素只有一个前驱和后继。<br>2、线性表是有限的。小朋友班级人数是有限的，元素个数当然也是有限的。无限的序列只存在于数学中。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BA%BF%E6%80%A7%E8%A1%A8.jpg" alt="线性表"></p>
<p>线性表的个数n(n&gt;=0)定义为线性表的长度，当n=0时，称为空表。<br>在非空表中的每个数据元素都有一个确定的位置，如a<sub>1</sub>是第一个数据元素，a<sub>n</sub>是最后一个数据元素，a<sub>i</sub>是第i个数据元素，称i为数据元素a<sub>i</sub>在线性表中的位序。</p>
<h3 id="线性表的抽象数据类型"><a href="#线性表的抽象数据类型" class="headerlink" title="线性表的抽象数据类型"></a>线性表的抽象数据类型</h3><p>回到刚才幼儿园小朋友的例子，老师为了让小朋友有秩序地出入，所以就考虑给他们排一个队，并且是长期使用的顺序，这个考虑和安排的过程其实就是一个线性表的创建和初始化的过程。</p>
<p>一开始没经验，把小朋友排好队后，发现有高有矮，就让小朋友解散重排，这是一个线性表重置为空表的操作。</p>
<p>排好了队，我们随时可以叫出队伍某一位置的小朋友及他的具体情况。<br>有时我们想知道某个小朋友是否是班里的小朋友，这就涉及到查找某个元素是否存在的操作。<br>而后有家长问老师，班里有多少个小朋友，这种获得线性表长度的问题也很普遍。<br>显然对于一个幼儿园来说，加入一个新的小朋友到队列中，或者因为某个小朋友生病需要移除某个位置，都是很正常的情况。对于一个线性表来说，插入数据和删除数据都是必须的操作</p>
<h3 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h3><h4 id="顺序存储的定义"><a href="#顺序存储的定义" class="headerlink" title="顺序存储的定义"></a>顺序存储的定义</h4><p>线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BA%BF%E6%80%A7%E9%A1%BA%E5%BA%8F.jpg" alt="线性顺序"></p>
<h4 id="顺序存储的方式"><a href="#顺序存储的方式" class="headerlink" title="顺序存储的方式"></a>顺序存储的方式</h4><p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89.jpg" alt="线性表"></p>
<p>说白了，就是在内存中找了块地，通过占位的形式，把一定的内存空间占了，然后把相同数据类型的数据元素依次存放在这块空地中。既然线性表中的每个数据元素的类型都相同，所以可以用C语言(其他语言也行)的一维数组来实现顺序存储结构，即把第一个数据元素存到数组下表为0的位置中，接着把线性表相邻的元素存储在数组中相邻的位置。</p>
<p>随着数据的插入，线性表的长度开始不断增大，不过线性表的当前长度不能超过存储容量，即数组的长度。想想也是，如果我们有十个人，只占了九个座，自然是坐不下的。</p>
<h4 id="数据长度和线性表长度的区别"><a href="#数据长度和线性表长度的区别" class="headerlink" title="数据长度和线性表长度的区别"></a>数据长度和线性表长度的区别</h4><p>数组的长度：存放线性表的存储空间的长度，存储分配后这个量一般是不变的。有个别同学可能会问，数组的大小一定不可以改变吗？我怎么看到有书谈到可以动态分配一维数组。是的，一般高级语言，比如C,C++都可以同编程手段实现动态内存分配， 不过这会带来性能上的损耗。</p>
<p>线性表的长度：线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是可以变化的。</p>
<h4 id="地址计算方法"><a href="#地址计算方法" class="headerlink" title="地址计算方法"></a>地址计算方法</h4><p>数组是从0开始第一个下标的，于是线性表的第i个元素是要存储在数组下标为i-1的位置，即数据元素的序号和存放它的数组下标之间存在对应关系</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9C%B0%E5%9D%80%E8%AE%A1%E7%AE%97.jpg" alt="地址"></p>
<p>用数组存储顺序表意味着要分配固定长度的数组空间，由于线性表中可以进行插入和删除操作，因此分配的数组空间要大于等于当前线性表长度。</p>
<p>其实，内存中的地址，就和图书馆或者电影院里的座位一样，都是有编号的。存储器中的每个存储单元都有自己的编号，这个编号叫做地址。</p>
<h3 id="顺序存储结构的插入和删除"><a href="#顺序存储结构的插入和删除" class="headerlink" title="顺序存储结构的插入和删除"></a>顺序存储结构的插入和删除</h3><h4 id="获得元素操作"><a href="#获得元素操作" class="headerlink" title="获得元素操作"></a>获得元素操作</h4><p>对于线性表的顺序存储结构来说，这个很简单，只要位置i的数值在数组下标范围内，就是把数组第i-1下标的值返回即可。</p>
<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A1%BA%E5%BA%8F%E6%8F%92%E5%85%A5.jpg" alt="插入"></p>
<p>插入算法的思路：<br>如果插入位置不合理，抛出异常；<br>如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；<br>从最后一个元素开始向前遍历到第i个位置(也可从前往后)，分别将他们都向后移动一个位置；<br>将要插入元素填入位置i处；<br>表长加1；</p>
<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A1%BA%E5%BA%8F%E5%88%A0%E9%99%A4.jpg" alt="删除"></p>
<p>删除算法的思路：<br>如果插入位置不合理，抛出异常；<br>取出删除元素；<br>从删除元素位置开始遍历到最后一个元素位置，分别将他们都向前移动一个位置；<br>将要插入元素填入位置i处；<br>表长减1；</p>
<p>线性表的顺序存储结构，在存、读数据时，不管是哪个位置，时间复杂度都是 0(1);而插入或删除时，时间复杂度都是 O(n)。这就说明 ，它比较适合元素个数不大变化，而更多是存取数据的应用。</p>
<h4 id="线性表顺序存储结构的优缺点"><a href="#线性表顺序存储结构的优缺点" class="headerlink" title="线性表顺序存储结构的优缺点"></a>线性表顺序存储结构的优缺点</h4><p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BA%BF%E6%80%A7%E9%A1%BA%E5%BA%8F%E4%BC%98%E7%BC%BA%E7%82%B9.jpg" alt="优缺点"></p>
<h3 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h3><h4 id="顺序存储结构的解决办法"><a href="#顺序存储结构的解决办法" class="headerlink" title="顺序存储结构的解决办法"></a>顺序存储结构的解决办法</h4><p>前面我们讲的线性表的顺序存储结构。它是有缺点，最大的缺点就是插入和删除需要移动大量的元素。</p>
<p>为什么当插入和删除的时候，就要移动大量的元素，仔细分析后，发现原因就在于相邻量元素的存储位置也具有邻居关系。他们的编号是1、2、3、…… 、n，他们在内存中的位置也是挨着的，中间没有空隙，当然就无法快速介入，而删除后，当中就会留出空隙，自然需要弥补。问题就出在这里。</p>
<h4 id="线性表链式存储结构的定义"><a href="#线性表链式存储结构的定义" class="headerlink" title="线性表链式存储结构的定义"></a>线性表链式存储结构的定义</h4><p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89.jpg" alt="链表"></p>
<p>链式表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。这就意味着，这些数据元素可以存在内存未被占用的位置。</p>
<p>为了表示每个数据元素a<sub>1</sub>与其直接后继数据元素a<sub>i+1</sub>之间的逻辑关系，对数据元素a<sub>i</sub>来说，除了存储其本身的信息之外，还需要存储一个指示其直接后继的信息(即直接后继的存储位置)。我们把存储数据元素信息的域称为数据域。把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链。这两部分信息组成元素a<sub>i</sub>的存储映像，称为结点(Node)</p>
<p>n个结点(a<sub>i</sub>)链结成一个链表，即为线性表的链式存储结构，因为此链表中的每个结点只包含一个指针域，所以叫做单链表。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E9%93%BE%E8%A1%A81.jpg" alt="单链表"></p>
<p>对于线性表来说，总得有个头有个尾，我们把链表中第一个结点的存储位置叫做头指针，那么整个链表的存取就必须是头指针开始进行了。<br>对于最后一个结点来说，它的直接后继是不存在的。所以我们规定，线性链表的最后一个结点指针为“空”(通常用NULL或”^”符号表示)</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E9%93%BE%E8%A1%A82.jpg" alt="单链表"></p>
<p>有时，我们为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信息，谁叫它是第一个呢，有这个特权。也可以存储如线性表的长度等附加信息，头结点的指针域指向第一个存储指向第一个结点的指针。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%B4%E7%BB%93%E7%82%B9%E5%8D%95%E9%93%BE%E8%A1%A8.jpg" alt="链表"></p>
<h4 id="头指针和头结点的异同"><a href="#头指针和头结点的异同" class="headerlink" title="头指针和头结点的异同"></a>头指针和头结点的异同</h4><p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%B4%E6%8C%87%E9%92%88%E4%B8%8E%E5%A4%B4%E7%BB%93%E7%82%B9%E5%BC%82%E5%90%8C.jpg" alt="头指针"></p>
<h4 id="线性表链式存储结构代码描述"><a href="#线性表链式存储结构代码描述" class="headerlink" title="线性表链式存储结构代码描述"></a>线性表链式存储结构代码描述</h4><p>若线性表为空表，则头结点的指针域为空，头指针指向此空域</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%A9%BA%E9%93%BE%E8%A1%A8.jpg" alt="链表"></p>
<p>由于我们并不关心链表在内存中的存储位置，所以可以用以下存储示意图来表示单链表。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%97%A0%E5%A4%B4%E7%BB%93%E7%82%B9%E5%8D%95%E9%93%BE%E8%A1%A8.jpg" alt="链表"></p>
<p>带有头结点单链表</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%B4%E7%BB%93%E7%82%B9%E5%8D%95%E9%93%BE%E8%A1%A8.jpg" alt="链表"></p>
<p>带头结点空链表</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%A9%BA%E9%93%BE%E8%A1%A8.jpg" alt="链表"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">LinkList</span>;</span> <span class="comment">/*定义LinkList*/</span></span><br></pre></td></tr></table></figure>

<p>从上述的结构定义中，我们就可以知道，结点由存放数据元素的数据域和存放后继结点地址的指针域组成。<br>假设p是指向线性表第i个元素的指针(即p可以说是线性表的第i个元素)，则该结点a<sub>i</sub>的数据域我们可以用p-&gt;data来表示。p-&gt;data的值是一个数据元素，结点a<sub>i</sub>的指针域可以用p-&gt;next来表示，p-&gt;next的值是一个指针，是一个指向第i+1个元素的指针。也就是说，如果p-&gt;data=a<sub>i</sub>，p-&gt;next-&gt;data=a<sub>i+1</sub>。</p>
<h4 id="个人对指针的理解"><a href="#个人对指针的理解" class="headerlink" title="个人对指针的理解"></a>个人对指针的理解</h4><p>趁机看了会儿指针的概念，感觉懂一点了<br>先举个例子, int* p和int *p的理解方式<br>我个人认为int* p更好理解，这代表着变量p是int*这个类型的<br>而我们把 int* 还有其他的什么*，char*，string*啊，统称为指针类型，它们的变量也就叫做指针<br>int* p = &q;这句话在这种方式下很好理解，就是指针p存放着q的地址<br>而int*要区别于这种情况</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p;</span><br><span class="line">*p = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>这种情况两个*的意思是不同的，上面的那个是指针类型，下面的是间接寻址运算符<br>基于以上的理解，p=p-&gt;next也就很好理解了，其实就是地址的变换，不管是p还是p-&gt;next都是地址，然后只不过让p等于下个结点的地址罢了。</p>
<hr>
<p>而ElemType a = p-&gt;data则又牵扯到指针与结构体之间的关系了<br>首先我们要搞清楚-&gt;是啥<br>-&gt;是（结构体、类、共同体等）的取成员运算符，p-&gt;相当于：(*p).<br>p一定是一个指针类型<br>也就是说能用-&gt;取成员运算符的只有指针类型</p>
<p>在使用结构体的时候，如果你选择用指针指向该结构体<br>如：struct Data * p  那你就得用-&gt;来调用结构体中的属性 p-&gt;xxx<br>如果你直接声明一个结构体<br>如：struct Data A 你可以直接用.来调用  A.xxx就行了</p>
<h3 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h3><p>获得链表第i个数据的算法思路：<br>1、声明一个结点p指向链表的第一个结点，初始化j从1开始；<br>2、当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一节点，j累加1；<br>3、若到链表末尾p为空，则说明第i个元素不存在；<br>4、否则查找成功，返回结点p的数据；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始条件：顺序线性表L已存在，1&lt;=i&lt;=ListLength(L)*/</span></span><br><span class="line"><span class="comment">/*操作结果：用e返回L中第i个元素的值*/</span></span><br><span class="line"><span class="function">Status <span class="title">GetElem</span> <span class="params">(LinkList L, <span class="keyword">int</span> i, ElemType* e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    LinkList p;     <span class="comment">/*声明一结点p*/</span></span><br><span class="line">    p = L-&gt;next;    <span class="comment">/*让p指向链表L中的第一个结点*/</span></span><br><span class="line">    j=<span class="number">1</span>;       <span class="comment">/*j为计数器*/</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j &lt; i)<span class="comment">/*p不为空或者计数器j还没有等于i时，循环继续*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next; <span class="comment">/*让p指向下一个结点*/</span></span><br><span class="line">        ++j;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p||j&gt;i)<span class="comment">/*第i个元素不存在*/</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    *e = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于单链表的结构中没有定义表长，所以不能事先知道要循环的次数，因此也就不方便用for来控制循环。其主要核心思想就是工作指针后移。</p>
<h3 id="单链表的插入与删除"><a href="#单链表的插入与删除" class="headerlink" title="单链表的插入与删除"></a>单链表的插入与删除</h3><h4 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h4><p>先来看单链表的插入。假设存储元素e的结点为s，要实现结点p，p-&gt;next和s之间的逻辑变化，只需要将结点s插入到结点p和p-&gt;next之间即可。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5.jpg" alt="链表"></p>
<p>s-&gt;next = p-&gt;next;  p-&gt;next=s;<br>只能在已知结点后插入结点</p>
<p>对于单链表的表头和表尾的特殊情况，操作是相同的</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A1%A8%E5%A4%B4%E8%A1%A8%E5%B0%BE%E6%8F%92%E5%85%A5.jpg" alt="链表"></p>
<h4 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h4><p>现在我们再来看单链表的删除，设存储元素a<sub>1</sub>的结点为q，要实现将结点q删除单链表的操作，其实就是将它的前继结点的指针绕过，指向它的后继结点即可。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9.jpg" alt="链表"></p>
<p>有两种思路：<br>1、必须要知道被删除结点的前继结点，例如被删除结点q的前继结点为p，<br>   q = p-&gt;next; q-&gt;next = p-&gt;next;或者q-&gt;next = q-&gt;next-&gt;next;<br>2、第二种只需要知道被删除结点，但是该节点不能是最后一个结点，假设当前结点为q，利用<br>   q-&gt;val = q-&gt;next-&gt;val; q-&gt;next = q-&gt;next-&gt;next;</p>
<p>分析一下刚才我们讲解的单链表的插入和删除算法，我们发现，它们其实都是两部分组成：第一部分就是遍历查找第i个元素(一般也需要赵丹它的前继结点)；第二部分就是插入和删除</p>
<h3 id="单链表的整表创建"><a href="#单链表的整表创建" class="headerlink" title="单链表的整表创建"></a>单链表的整表创建</h3><p>回顾一下，顺序存储结构的创建，其实就是一个数组的初始化，即声明一个类型和大小的数组并赋值的过程。而单链表和顺序存储结构就不一样，它不像顺序存储结构这么集中，它可以很散，是一种动态结构。对于每个链表来说，它所占用空间的大小和位置是不需要预先分配划定的，可以根据系统的情况和实际的需求即时生成。</p>
<p>所以创建单链表的过程就是一个动态生成链表的过程。即从“空表”的初始状态开始，依次建立各元素结点，并逐个插入链表。</p>
<p>把新结点都放到最后。我们把每次新结点都插在终端结点的后面，这种算法称之为尾插法。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%B0%BE%E6%8F%92%E6%B3%95.jpg" alt="链表"></p>
<h3 id="单链表的整表删除"><a href="#单链表的整表删除" class="headerlink" title="单链表的整表删除"></a>单链表的整表删除</h3><p>部分代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line">    q=p-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p=q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要知道p是一个结点，它除了有数据域，还有指针域。你在做free(p)时，其实是在对它整个结点进行删除和内存释放的工作。<br>所以要在删除p之前找到它的后继结点并存储起来，这就是变量q的作用</p>
<h3 id="单链表结构与顺序存储结构优缺点"><a href="#单链表结构与顺序存储结构优缺点" class="headerlink" title="单链表结构与顺序存储结构优缺点"></a>单链表结构与顺序存储结构优缺点</h3><p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%BC%98%E7%BC%BA%E7%82%B9.jpg" alt="链表"></p>
<p>若线性表需要频繁查找，很少进行插入和删除操作，宜采用顺序存储结构。若需要频繁插入和删除时，宜采用单链表结构。</p>
<p>当线性表中的元素个数变化较大或者根本不知道有多大时，最好采用单链表结构，这样可以不需要考虑存储空间大小的问题。</p>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>对于单链表，由于每个节点只存储了向后的指针，到了尾标志就停止了向后链的操作，这样，当中某一结点就无法找到它的前驱结点，不能回到从前。</p>
<p>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表。</p>
<p>空循环链表<br><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%A9%BA%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.jpg" alt="链表"></p>
<p>非空循环链表<br><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%9D%9E%E7%A9%BA%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.jpg" alt="链表"></p>
<p>其实循环链表和单链表的主要差异就在于循环的判断条件上，原来是判断p-&gt;next是否为空，现在则是p-&gt;next不等于头结点，则循环未结束。</p>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>双向链表是在单链表的每个结点中，再设置一个指向其前驱结点的指针域，所以在双向链表中的结点都有两个指针域，一个指向直接后继，一个直接前驱。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.jpg" alt="链表"></p>
<h3 id="总结回顾-1"><a href="#总结回顾-1" class="headerlink" title="总结回顾"></a>总结回顾</h3><p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE.jpg" alt="链表"></p>
<h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h3 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h3><h4 id="栈的定义-1"><a href="#栈的定义-1" class="headerlink" title="栈的定义"></a>栈的定义</h4><p>栈的特点在于“先进后出”。</p>
<p>栈：限定仅在表尾进行插入和删除操作的线性表</p>
<p>我们把允许插入和删除的一端称为栈顶(top)，另一端称为栈底，不含任何数据元素的栈称为空栈。栈又称为后进先出(Last In First Out)的线性表，简称LIFO结构。</p>
<p>首先要明白栈是一个线性表，也就是说，栈里面的元素具有线性关系，即前驱后继关系。只不过它是一种特殊的线性表而已。定义中说是在线性表的表尾进行插入和删除操作，这里表尾指的是栈顶，而不是栈底。</p>
<p>它的特殊之处就在于限制了这个线性表的插入和删除位置。它始终只在栈顶进行。这也就使得：栈底是固定的，最先进栈的只能在栈底。</p>
<p>栈的插入操作，叫做进栈，也称作压栈、入栈。类似子弹入弹夹。<br>栈的删除操作，叫做出栈，也有的叫弹栈。如同弹夹中的子弹出夹。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%BF%9B%E6%A0%88%E5%87%BA%E6%A0%88.jpg" alt="栈"></p>
<h4 id="进栈出栈变化形式"><a href="#进栈出栈变化形式" class="headerlink" title="进栈出栈变化形式"></a>进栈出栈变化形式</h4><p>最先进栈的元素不一定最后出栈，它可以进去后立即出栈，也可以等它的下一个出了以后再出栈。栈堆线性表的插入和删除的位置作了限制，并没有对元素进出的时间进行限制，也就是说，在不是所有元素都进栈的情况下，事先进去的元素也可以出栈，只要保证是栈顶元素出栈就可以了。</p>
<h3 id="栈的抽象数据类型"><a href="#栈的抽象数据类型" class="headerlink" title="栈的抽象数据类型"></a>栈的抽象数据类型</h3><p>对于栈的插入操作，我们称之为push压栈</p>
<p>对于删除操作，称为pop出栈</p>
<h3 id="栈的顺序存储结构的实现"><a href="#栈的顺序存储结构的实现" class="headerlink" title="栈的顺序存储结构的实现"></a>栈的顺序存储结构的实现</h3><h4 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h4><p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%88%E7%9A%84%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89.jpg" alt="栈"></p>
<p>既然栈是线性表的特例，那么栈的顺序其实也是线性表顺序存储的简化，我们简称为顺序栈。<br>以下标为0的一端作为栈底，因为首元素都存在栈底，变化为小，所以让它作栈底。</p>
<p>现有一个栈，StackSize是5，则栈的普通情况，空栈和栈满的情况如下</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%88%E5%9B%BE.jpg" alt="栈"></p>
<h4 id="栈的顺序存储结构————进栈操作"><a href="#栈的顺序存储结构————进栈操作" class="headerlink" title="栈的顺序存储结构————进栈操作"></a>栈的顺序存储结构————进栈操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">stack1.push(num);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="栈的顺序存储结构————出栈操作"><a href="#栈的顺序存储结构————出栈操作" class="headerlink" title="栈的顺序存储结构————出栈操作"></a>栈的顺序存储结构————出栈操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">stack1.pop();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="两栈共享空间"><a href="#两栈共享空间" class="headerlink" title="两栈共享空间"></a>两栈共享空间</h3><p>其实栈的顺序存储还是很方便的，因为它只准栈顶进出元素，所以不存在线性表插入和删除时需要移动元素的问题。</p>
<p>两栈共享空间的方法：<br>数组有两个端点，两个栈有两个栈底。让一个栈的栈底为数组的始端，即下标为0处，另一个栈为栈的末端，即下标为数组长度n-1处。这样，两个栈如果增加元素，就是两端点向中间延伸。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%A4%E6%A0%88%E5%85%B1%E4%BA%AB%E7%A9%BA%E9%97%B4.jpg" alt="栈"></p>
<p>其实关键思路是：它们在数组的两端，向中间靠拢。top1和top2是栈1和栈2的栈顶指针，可以想象，只要它们俩不见面，两个栈就可以一直使用。<br>使用这样的数据结构，通常都是当两个栈的空间需求有相反的关系时，也就是一个栈增长时另一个在缩短的情况。</p>
<h3 id="栈的链式存储结构及实现"><a href="#栈的链式存储结构及实现" class="headerlink" title="栈的链式存储结构及实现"></a>栈的链式存储结构及实现</h3><h4 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h4><p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%93%BE%E6%A0%88%E7%9A%84%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89.jpg" alt="栈"></p>
<p>栈的链式存储结构简称为链栈。</p>
<p>将栈顶放在单链表头部，另外都已经有了栈顶在头部了，单链表中比较常用的头结点也就失去了意义，通常对于链栈来说，是不需要头结点的。<br>对于链栈来说，基本不存在栈满的情况，除非内存已经没有使用空间了，那时计算机已经死机了。<br>对于空栈来说，链表的定义是头指针指向空，那么链栈的空其实就是.top()=NULL;</p>
<h4 id="栈的链式存储结构————进栈操作"><a href="#栈的链式存储结构————进栈操作" class="headerlink" title="栈的链式存储结构————进栈操作"></a>栈的链式存储结构————进栈操作</h4><p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%93%BE%E6%A0%88%E8%BF%9B%E6%A0%88.jpg" alt="栈"></p>
<h4 id="栈的链式存储结构————出栈操作"><a href="#栈的链式存储结构————出栈操作" class="headerlink" title="栈的链式存储结构————出栈操作"></a>栈的链式存储结构————出栈操作</h4><p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%93%BE%E6%A0%88%E5%87%BA%E6%A0%88.jpg" alt="栈"></p>
<h3 id="栈的作用"><a href="#栈的作用" class="headerlink" title="栈的作用"></a>栈的作用</h3><p>有的同学可能会觉得，用数组或者链表直接实现功能不就行了吗？为啥还要引入栈这样的数据结构呢？这个问题问得好。<br>其实这和我们明明就有两条腿可以走路，干吗还要乘汽车、火车、飞机一样。理论上，陆地上的任何地方，你都可以靠双脚走到，可那需要多少时间和精力呢？我们更关注的是到达而不是如何去的过程。<br>栈的引入简化了程序设计的问题，划分了不同关注的层次，使得思考范围变得更小，更加聚焦于我们要解决的问题核心。反之，像数组等，因为要分散精力去考虑数组的下标增减等细节问题，反而掩盖了问题的本质。<br>所以现在的许多高级语言，比如Java、C#、C++等都有对栈结构的封装，你可以不用关注它的实现细节。就可以直接使用Stack的push和pop方法，非常方便。</p>
<h3 id="个人对于递归的理解"><a href="#个人对于递归的理解" class="headerlink" title="个人对于递归的理解"></a>个人对于递归的理解</h3><p>一言以蔽之就是函数自己调用自己，也就是重复操作。</p>
<p>但是对于重复操作就有个问题，什么时候停呢？不弄懂这个问题，就没法进行递归，无限循环是没有意义的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function">    <span class="title">print</span> <span class="title">i</span></span></span><br><span class="line">  if i &lt;= 1: #基线条件</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">else</span>: <span class="comment">#递归条件</span></span><br><span class="line">   countdown (i<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h3><p>队列(queue)是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</p>
<p>队列是一种先进先出(First In First Out)的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。</p>
<p>队列就跟买火车票的时候大家排队买票一样，在队头的人买到了票，他出队，新来的人站到队尾，不能插队。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%98%9F%E5%88%97%E5%9B%BE%E7%A4%BA.jpg" alt="队列"></p>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>线性表有顺序存储和链式存储、栈是线性表、所以有两种存储方式。同样，队列作为一种特殊的线性表，也同样存在这两种存储方式。我们先来看队列的顺序存储结构。</p>
<h4 id="队列顺序存储的不足"><a href="#队列顺序存储的不足" class="headerlink" title="队列顺序存储的不足"></a>队列顺序存储的不足</h4><p>我们假设一个队列有n个元素，则顺序存储的队列需要建立一个大于n的数组，并把队列的所有元素存储在数组的前n个单元，数组下标为0的一端即是队头。所谓的入队列操作，其实就是在队尾追加一个元素，不需要移动任何元素，因此时间复杂度为O(1)</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%A5%E9%98%9F%E5%88%97.jpg" alt="队列"></p>
<p>与栈不同的是，队列元素的出列是在队头，即下标为0的位置，那也就意味着，队列中的所有元素都得向前移动，以保证队列的队头，也就是下标为0的位置不为空(还是跟买票一个道理，队伍中的人也要不停的向前移动)，此时时间复杂度为O(n)</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BA%E9%98%9F%E5%88%971.jpg" alt="队列"></p>
<p>但仔细想想，为什么出队列的时候一定要全部移动呢，如果不去限制队列的元素必须存储在数组的前n个单元这一条件，出队的性能就会大大增加。也就是说，队头不需要一定在下标为0的位置</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BA%E9%98%9F%E5%88%972.jpg" alt="队列"></p>
<p>为了避免当只有一个元素时，队头和队尾重合使处理变得麻烦，所以引入两个指针，front指针指向队头元素，rear指针指向队尾元素的下一个位置，这样当front等于rear时，队列不是还剩一个元素，而是空队列</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%98%9F%E5%88%97%E6%BC%94%E7%A4%BA.jpg" alt="队列"></p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%81%87%E6%BA%A2%E5%87%BA.jpg" alt="队列"></p>
<p>但有问题，假设这个队列的总个数不超过5个，但目前如果接着入队的话，因数组末尾元素已经占用，再向后加，就会产生数组越界的错误，可实际上，我们的队列在下标为0和1的地方还是空闲的。我们把这种现象叫做“假溢出”。</p>
<h4 id="循环队列定义"><a href="#循环队列定义" class="headerlink" title="循环队列定义"></a>循环队列定义</h4><p>所以解决假溢出的办法就是后面满了，就再从头开始，也就是头尾相接的循环。我们把队列的这种头尾相接的顺序存储结构称为循环队列。</p>
<p>接着刚才的问题</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%971.jpg" alt="队列"></p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%972.jpg" alt="队列"></p>
<p>此时问题又出来了，我们刚才说空队列时，front等于rear，现在当循环队列满时，也是front 等于 rear，那么如何判断此时的队列究竟是空还是满呢？</p>
<p>办法一：设置一个标志变量flag，当front == rear，且flag = 0时队列空，当front==rear，且flag = 1时队列满。</p>
<p>办法二：当队列空是，条件就是front == rear，当队列满时，我们修改其条件，保留一个元素空间。也就是说、队列满时，数组中还有一个空闲单位。当如下图时，我们就认为此队列已经满了<br><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%973.jpg" alt="队列"></p>
<p>重点讨论第二种方法，由于rear可能比front大(没循环)，也可能比front小，所以尽管它们只相差一个位置时就是满的情况，但也可能是相差整整一圈，就像上图所示的两种情况。所以若队列的最大尺寸为QueueSize，那么队列满的条件是 (rear+1) % QueueSize == front<br>通用的计算队列长度的公式为：<br>(rear - front + QueueSize) % QueueSize</p>
<h3 id="队列的链式存储结构及实现"><a href="#队列的链式存储结构及实现" class="headerlink" title="队列的链式存储结构及实现"></a>队列的链式存储结构及实现</h3><p>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列。为了操作上的方便，我们将队头指针(front)指向链队列的头结点，而队尾指针(rear)指向终端结点。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%93%BE%E9%98%9F%E5%88%971.jpg" alt="队列"></p>
<p>空队列时，front和rear都指向头结点</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%A9%BA%E9%93%BE%E9%98%9F%E5%88%97.jpg" alt="队列"></p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%93%BE%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84.jpg" alt="队列"></p>
<h4 id="队列的链式存储结构——入队操作"><a href="#队列的链式存储结构——入队操作" class="headerlink" title="队列的链式存储结构——入队操作"></a>队列的链式存储结构——入队操作</h4><p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%93%BE%E9%98%9F%E5%88%97%E5%85%A5%E9%98%9F.jpg" alt="队列"></p>
<h4 id="队列的链式存储结构——出队操作"><a href="#队列的链式存储结构——出队操作" class="headerlink" title="队列的链式存储结构——出队操作"></a>队列的链式存储结构——出队操作</h4><p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%93%BE%E9%98%9F%E5%88%97%E5%87%BA%E9%98%9F.jpg" alt="队列"></p>
<h3 id="总结回顾-2"><a href="#总结回顾-2" class="headerlink" title="总结回顾"></a>总结回顾</h3><p>栈(stack)是限定仅在表尾进行插入和删除操作的线性表<br>队列(queue)是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。<br>它们均可以用线性表的顺序存储结构来实现，但都存在着顺序存储的一些弊端。因此它们各自有各自的技巧来解决这些问题。<br>对于栈来说，如果是两个相同数据类型的栈，则可以用数组的两端作栈底的方法来让两个栈共享数据，这就可以最大化地利用数组的空间。<br>对于队列来说，为了避免数组插入和删除时需要移动数据，于是就引入了循环队列，使得队头和队尾可以在数组中循环变化。解决了移动数据的时间损耗，使得本来插入和删除是O(n)的时间复杂度变成了O(1)。<br>它们也都可以通过链式存储结构来实现，实现原则上与线性表基本相同。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE.jpg" alt="栈和队列"></p>
<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><h3 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h3><p>串是有零个或多个字符组成的有限序列，又名叫字符串。</p>
<p>一般记为 s=”zifuchuan”,其中，s是串的名称，用双引号括起来的字符序列是串的值，注意单引号不属于串的内容。<br>零个字符的串称为空串，它的长度为零，可以直接用双引号“ “” ”表示，也可以用希腊字母“Φ”表示。</p>
<p>空格串是只包含空格的串。注意它与空串的区别，空格串是有内容，有长度的，而且可以不止有一个空格。</p>
<p>子串和主串，串中任意个数的连续字符组成的子序列称为该串的子串，相应地，包含子串的串称为主串。</p>
<p>子串在主串中的位置就是子串的第一个字符在主串中的序号。</p>
<h3 id="串的比较"><a href="#串的比较" class="headerlink" title="串的比较"></a>串的比较</h3><p>给定两个串：s=”a<sub>1</sub>……an”，t=”b<sub>1</sub>……bm”，当满足以下条件之一时,s &lt; t</p>
<p>1.n &lt; m，且a<sub>i</sub> = b<sub>i</sub> (i = 1,2,3,4……,n)<br>例如当s = “hap”，t = “happy”，就有s &lt; t。因为t比s多两个字母。</p>
<p>2.存在某个k &lt;= min(m,n)，使得a<sub>i</sub> = b<sub>i</sub> (i = 1,2,3,4……,k-1),a<sub>k</sub> = b<sub>k</sub><br>例如当s=”happen”，t=”happy”，因为两串的前4个字母均相同，而两串第5个字母(k值)，字母e的ASCII码是101，而字母y的ASCII码是121，显然e &lt; y，所以s &lt; t。</p>
<p>如果觉得这样的数学定义很抽象，其实举个例子就是查字典。我们的英语字典，通常都是上万个单词的有序排列。就大小而言，前面的单词比后面的小。你在查找单词的过程，其实就是在比较字符串大小的过程。</p>
<h3 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h3><p>串的存储结构与线性表相同，分为两种</p>
<h4 id="串的顺序存储结构"><a href="#串的顺序存储结构" class="headerlink" title="串的顺序存储结构"></a>串的顺序存储结构</h4><p>串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的。按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区。一般是用定长数组来定义。</p>
<p>既然是定长数组，就存在一个预定义的最大串长度，一般可以将实际的串长度值保存在数组的0下标位置，有的书中也会定义存储在数组的最后一个下标位置。但也有些编程语言不想这么做，觉得存个数字占个空间很麻烦。它规定在串值后面加一个不计入串长度的结束标记字符，比如”\0”来表示串的终结，这个时候，如果你想要知道串的长度，就得先遍历一边串才能知道。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A1%BA%E5%BA%8F%E4%B8%B2.jpg" alt="串"></p>
<p>刚才讲的串的顺序存储方式其实是有问题的，因为字符串的操作，比如两串的连接Concat、新串的插入StrInsert，以及字符串的替换Replace，都有可能使得串序列的长度超过了数组的长度MaxSize</p>
<p>于是对于串的顺序存储，有一些变化，串值的存储空间可以在执行过程中分配而得。比如在计算机中有一个自由存储区，叫做”堆”。这个堆可由C语言的动态分配函数malloc()和free()来管理。</p>
<h4 id="串的链式存储结构"><a href="#串的链式存储结构" class="headerlink" title="串的链式存储结构"></a>串的链式存储结构</h4><p>对于串的链式存储结构，与线性表是相似的，但由于串结构的特殊性，结构中的每个元素数据是一个字符，如果也简单的应用链表存储串值，一个结点对应一个字符，就会存在很大的空间浪费。因此，一个结点可以存放一个字符，也可以考虑存放多个字符，最后一个结点若是未被占满时，可以用”#”或其他非串值字符补全</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%93%BE%E5%BC%8F%E4%B8%B2.jpg" alt="串"></p>
<p>当然，这里一个结点存多少个字符才合适就变得尤为重要，这会直接影响着串处理的效率，需要根据实际情况做出选择。<br>但串的链式存储结构除了在连接串和串操作时有一定的方便之外，总的来说不如顺序存储灵活，性能也不如顺序结构好。</p>
<h3 id="总结回顾-3"><a href="#总结回顾-3" class="headerlink" title="总结回顾"></a>总结回顾</h3><p>这一章我们重点讲解了”串”这样的数据结构，串(string)是由零个或多个字符组成的有限序列，又名叫字符串。本质上，它是一种线性表的扩展，但相对于线性表关注一个个元素来说，我们对串这种结构更多的是关注它子串的应用问题，如查找、替换等操作。现在的高级语言都有针对串的函数可以调用。</p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树：树(Tree)是n (n&gt;=0) 个结点的有限集。n=0时称为空树。在任意一棵非空树种：(1)有且仅有一个特定的称为根(Root)的结点；(2)n&gt;1时，其余节点可以分为m (m&gt;0) 个互不相交的有限集，其中每一个集合本身又是一棵树，并且称为根的子树(SubTree)。</p>
<h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><p>之前我们一直在谈的是一对一的线性结构，可现实中，还有很多一对多的情况需要处理，所以我们需要研究这种一对多的数据结构——“树”</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%91.jpg" alt="树"></p>
<p>树的定义除了在”树”一节中讲到的，还有一种递归定义方法。也就是在树的定义之中还用到了树的概念，这是一种比较新的定义方法。图中的子树T1和子树T2就是根结点的A的子树。当然，D、G、H、I组成的树又是B为结点的子树。E、J组成的树是C为结点的子树。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89.jpg" alt="树"></p>
<p>还有两点需要强调：<br>1、n &gt; 0时根结点是唯一的，不可能存在多个根结点，别和现实中的大树混在一起，现实中的树有很多根须，那是真实的树，数据结构中的树是只能有一个根结点。<br>2、m &gt; 0时，子树的个数没有限制。但它们一定是互不相交的。</p>
<h4 id="结点及相关概念"><a href="#结点及相关概念" class="headerlink" title="结点及相关概念"></a>结点及相关概念</h4><p>结点度就是这个结点的孩子数量，例如有左右孩子的结点，它的度为2，如果只有左孩子或者只有右孩子的结点，它的度就是1，叶结点就是度为0的结点（没有孩子）</p>
<p>叶子结点是离散数学中的概念。一棵树当中没有子结点（即度为0）的结点称为叶子结点，简称“叶子”。 叶子是指出度为0的结点，又称为终端结点。</p>
<p>“高度”这个概念，其实就是从下往上度量，比如我们要度量第10层楼的高度、第13层楼的高度，起点都是地面。所以，树这种数据结构的高度也是一样，从最底层开始计数，并且计数的起点是0。<br>“深度”这个概念在生活中是从上往下度量的，比如水中鱼的深度，是从水平面开始度量的。所以，树这种数据结构的深度也是类似的，从根结点开始度量，并且计数起点也是0。<br>“层数”跟深度的计算类似，不过，计数起点是1（生活中，不可能有人说自己家在第0层吧，哈哈。），也就是说根节点的位于第1层。</p>
<p>节点的高度：节点到叶子节点的最长路径（边数）<br>节点的深度：根节点到这个节点所经历的边的个数<br>节点的层数：节点的深度 + 1<br>树的高度：根节点的高度<br>树中结点总个数=（所有的结点的度数)+1</p>
<p>树的结点包含一个数据元素及若干指向其子树的分支(指向子树的分支就是结点含有一些指针数据成员, 指向它的子树)<br>结点拥有的子树数称为结点的度(Degree)。度为0的结点称为叶子结点(Leaf)或终端结点；<br>度不为0的结点称为非终端结点或分支节点。<br>除根结点之外，分支节点也称为内部结点。树的度是树内部各结点的度的最大值。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E7%82%B9%E5%88%86%E7%B1%BB.jpg" alt="树"></p>
<h5 id="结点间关系"><a href="#结点间关系" class="headerlink" title="结点间关系"></a>结点间关系</h5><p>结点的子树的根称为该结点的子结点，相应地，该结点称为子节点的父结点。<br>同一个父结点的子结点之间互称兄弟结点。<br>结点的祖先是从根到该结点所经分支上的所有结点。反之，以某结点为根的子树中的任一结点都称为该结点的子孙。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E7%82%B9%E9%97%B4%E5%85%B3%E7%B3%BB.jpg" alt="树"></p>
<h5 id="树的其他相关概念"><a href="#树的其他相关概念" class="headerlink" title="树的其他相关概念"></a>树的其他相关概念</h5><p>结点的层次(Level)从根开始定义起，根为第一层，根的子结点为第二次。若某结点在第n层，则其子树的根就在第n+1层。<br>其父节点在同一层的结点称为堂兄弟。<br>树中结点的最大层次称为树的深度(Depth)或高度。下图树的深度为4</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6.jpg" alt="树"></p>
<p>如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。<br>森林(Forest)是m(m&gt;0)棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林，上图的两棵子树就可以理解成森林。</p>
<p>对比线性表和树的结构，它们有很大不同</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%92%8C%E6%A0%91%E7%BB%93%E6%9E%84.jpg" alt="树"></p>
<h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><p>由于简单的顺序存储结构并不能满足树的实现要求。<br>不过充分利用顺序存储和链式存储结构的特点，完全可以实现对树的存储结构的表示。我们在这里主要介绍三种不同的表示方法：双亲表示法、孩子表示法、孩子兄弟表示法</p>
<h4 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h4><p>树这种结构除了根结点外，其余任何一个结点，它不一定有子结点，但是一定且仅有一个父结点。</p>
<p>我们假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其父结点的位置</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E7%82%B9%E7%BB%93%E6%9E%84%E5%9B%BE1.jpg" alt="树"></p>
<p>其中data是数据域，存储结点的数据信息。而parent是指针域，存储该结点的双亲在数组中的下标。</p>
<p>有了这样的结构定义，我们就可以实现双亲表示法了。由于根结点是没有父结点的，所以我们约定根结点的位置域设置为-1，这也就意味着，我们所有的节点都存有它父结点的位置</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95.jpg" alt="树"></p>
<p>这样的存储结构，我们可以根据结点的parent指针很容易找到它的双亲结点，所用的时间复杂度为O(1)，直到parent为-1时，表示找到了树结点的根。可如果我们想要知道结点的孩子是什么，对不起，得遍历整个结构才行。</p>
<p>当然有改进方法，但这里就不再赘述了。</p>
<h4 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h4><p>这里我们只谈下孩子表示法的具体实现方法：把每个结点的子结点排列起来，以单链表作为存储结构，则 n 个结点有 n 个子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95.jpg" alt="树"></p>
<h4 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h4><p>任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个子结点和此结点的右兄弟。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E7%82%B9%E7%BB%93%E6%9E%84%E5%9B%BE2.jpg" alt="树"></p>
<p>其中data是数据域，firstchild为指针域，存储该结点的第一个子结点的存储地址，rightsib是指针域，存储该结点的右兄弟结点的存储地址。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95.jpg" alt="树"></p>
<h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><p>二叉树是n(n&gt;=0)个结点的有限集合，该集合或者为空集(称为空二叉树)，或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%BE%E4%BE%8B.jpg" alt="树"></p>
<h4 id="二叉树的特点"><a href="#二叉树的特点" class="headerlink" title="二叉树的特点"></a>二叉树的特点</h4><p>二叉树的特点有：</p>
<p>1.每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点(子树数量不大于2)。注意不是只有两棵子树，而是最多有，没有子树或者有一棵子树都是可以的。</p>
<p>2.左子树和右子树是有顺序的，次序不能任意颠倒。就像人有双手，但显然左手和右手是不一样的。</p>
<p>3.即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。树1和树2是同一棵树，但它们却是不同的二叉树。就好像你不小心摔伤了手，伤的是左手还是右手，对你的生活影响是完全不同的。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%9112.jpg" alt="树"></p>
<p>二叉树具有五种基本形态：</p>
<p>1.空二叉树<br>2.只有一个根结点<br>3.根结点只有左子树<br>4.根结点只有右子树<br>5.根结点既有左子树又有右子树</p>
<h4 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h4><p>我们再来介绍一些特殊的二叉树。这些树可能暂时你不能理解它有什么用处，但可以先了解一下，以后会提到它们的实际用途。</p>
<p>1.斜树</p>
<p>顾名思义，斜树一定要是斜的，但是往哪边斜还是有讲究的。所有结点都只有左子树的二叉树叫左斜树。所有结点都只有右子树的二叉树叫右斜树。二者统称为斜树。<br>斜树有很明显的特点，就是每一层都只有一个结点，结点的个数与二叉树的深度相同。<br>有人会想，这也能叫树啊，这与我们的线性表结构不是一样吗？对的，其实线性表结构就可以理解为是树的一种极其特殊的表现形式。</p>
<p>2.满二叉树</p>
<p>在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.jpg" alt="树"></p>
<p>单是每个结点都存在左右子树，不能算是满二叉树，还必须要所有的叶子都在同一层上，这就做到了整棵树的平衡。因此，满二叉树的特点有：<br>1.叶子只能出现在最下一层。出现在其它层就不可能达到平衡<br>2.非叶子结点的度一定是2.否则就是“缺胳膊少腿”了<br>3.在同样深度的二叉树中，满二叉树的结点个数最多，叶子树最多</p>
<p>3.完全二叉树</p>
<p>对一棵具有n个结点的二叉树按层序编号(从左往右依次编号)，如果编号为i(1&lt;=i&lt;=n)的结点与同样深度的满二叉树编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.jpg" alt="树"></p>
<p>理解起来有些难度<br>首先从字面上要区分，“完全”和“满”的差异，满二叉树一定是完全二叉树，但完全二叉树不一定是满二叉树</p>
<p>从这里我也可以得出一些完全二叉树的特点：</p>
<p>1.叶子结点只能出现在最下面两层<br>2.最下层的叶子一定集中在左部连续位置<br>3.倒数二层，若有叶子结点，一定在右部连续位置<br>4.如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况<br>5.同样结点数的二叉树，完全二叉树的深度最小</p>
<p>我们可以得到一个判断某二叉树是否是完全二叉树的方法，那就是看着树的示意图，心中默默给每个结点按照满二叉树的结构逐层顺序编号，如果编号出现空档，就说明不是完全二叉树，否则就是。</p>
<h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><h4 id="性质1"><a href="#性质1" class="headerlink" title="性质1"></a>性质1</h4><p>在二叉树的第i层上至多有2<sup>i-1</sup>个结点(i&gt;=1)(等比数列第i项)</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.jpg" alt="树"></p>
<h4 id="性质2"><a href="#性质2" class="headerlink" title="性质2"></a>性质2</h4><p>深度为k的二叉树至多有2<sup>k</sup>-1个结点(k&gt;=1)(等比数列前i项和)<br>注意这里一定要看清楚，是2<sup>k</sup>-1，而不是2<sup>k-1</sup>。不记清楚的话性质1和性质2很容易混淆</p>
<h4 id="性质3"><a href="#性质3" class="headerlink" title="性质3"></a>性质3</h4><p>对任何一棵二叉树T，如果其终端结点(叶子结点)数为n<sub>0</sub>，度为2的结点数为n<sub>2</sub>，则n<sub>0</sub> = n<sub>2</sub> + 1</p>
<p>一棵二叉树，除了叶子结点外，剩下的就是度为1或2的结点数了，我们设n<sub>1</sub>为度是1的结点数。则树T结点总数为n = n<sub>0</sub> + n<sub>1</sub> + n<sub>2</sub></p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%A7%E8%B4%A83.jpg" alt="树"></p>
<p>上图中，结点总数为10，它是由A、B、C、D等度为2的结点，F、G、H、I、J等度为0的叶子结点和E这个度为1的结点组成。总和为4+1+5=10</p>
<h4 id="性质4"><a href="#性质4" class="headerlink" title="性质4"></a>性质4</h4><p>具有n个结点的完全二叉树的深度为[log<sub>2</sub>n+1] ([x]\表示不大于x的最大整数)</p>
<h4 id="性质5"><a href="#性质5" class="headerlink" title="性质5"></a>性质5</h4><p>如果对一棵有n个结点的完全二叉树(其深度为[log<sub>2</sub>n+1])的结点按层序标号(从第一层到第log<sub>2</sub>n+1]层，每层从左到右)，对任一结点i(1&lt;=i&lt;=n)有：<br>1.如果i=1，则结点i是二叉树的根，无父结点;如果i&gt;1，则其父结点编号是[i/2]</p>
<p>2.如果2i&gt;n，则结点i无左子结点(结点i为叶子结点);否则其左子结点就是结点2i</p>
<p>3.如果2i+1&gt;n，则结点i无右孩子;否则其右孩子是结点2i+1</p>
<p>接下来举个例子来理解这个性质。这是一个完全二叉树，度为4，结点总数为10</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%A7%E8%B4%A85.jpg" alt="树"></p>
<p>对于第一条来说是显然的，i=1 时就是根结点。i&gt;1时，比如结点7，它的双亲就是[7/2] = 3，结点9双亲就是[9/2] = 4</p>
<p>第二条，比如结点6，因为 2<em>6=12&gt;结点总数10，所以结点6无左孩子，它是叶子结点<br>同样，结点5，因为 2</em>5=10正好是结点总数10，所以它的左孩子是结点10</p>
<p>第三条，比如结点5，因为2<em>5+1=11，大于结点总数10，所以它无右孩子<br>而结点3，因为2</em>3+1=7小于结点总数10，所以它的右孩子结点是7</p>
<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="二叉树顺序存储结构"><a href="#二叉树顺序存储结构" class="headerlink" title="二叉树顺序存储结构"></a>二叉树顺序存储结构</h4><p>前面我们已经谈到了树的存储结构，并且谈到顺序存储对树这种一对多的关系结构实现起来是比较困难的。但是二叉树是一种特殊的树，由于其特殊性，使得用顺序存储结构也可以实现。</p>
<p>二叉树的顺序存储结构就是用一堆数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系，比如双亲与孩子的关系，左右兄弟关系等</p>
<p>先来看看完全二叉树的顺序存储，如下。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.jpg" alt="树"></p>
<p>将这棵二叉树存入到数组中，相应的下标对应其同样的位置，如下。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%95%B0%E7%BB%84.jpg" alt="树"></p>
<p>这下可以看出完全二叉树的优越性来了吧。由于它严格的定义，所以用顺序结构也可以表现出二叉树的结构来。</p>
<p>当然对于一般的二叉树，尽管层序编号不能反映逻辑关系、但是可以将其按完全二叉树编号。只不过，把不存在的结点设置为”^”而已。</p>
<p>但也会出现极端情况，比如一棵深度为k的右斜树，它只有k个结点，却需要分配2<sup>k</sup>-1 个存储空间，这显然是对存储空间的浪费，如下图，所以顺序存储结构一般只用于顺序二叉树</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8F%B3%E6%96%9C%E6%A0%91%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.jpg" alt="树"></p>
<h4 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h4><p>既然顺序存储适用性不强，我们就要考虑链式存储结构。二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们称这样的链表叫做二叉链表。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8.jpg" alt="树"></p>
<p>其中data是数据域，lchild和rchild都是指针域，分别存放指向左孩子和右孩子的指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">    TElemtype data;   <span class="comment">/*结点数据*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>   /*左右孩子指针*/</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#125; <span class="title">BiTNode</span>, *<span class="title">BiTree</span></span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="树"></p>
<p>就像树的存储结构中讨论的一样，如果有需要，还可以再增加一个指向其双亲的指针域，那样就称之为三叉链表。由于与树的存储结构类似，这里就不再说了。</p>
<h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><h4 id="二叉树的遍历原理"><a href="#二叉树的遍历原理" class="headerlink" title="二叉树的遍历原理"></a>二叉树的遍历原理</h4><p>二叉树的遍历是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。<br>这里有两个关键词：访问和次序。</p>
<h4 id="二叉树遍历方法"><a href="#二叉树遍历方法" class="headerlink" title="二叉树遍历方法"></a>二叉树遍历方法</h4><p>1.前序遍历  根一左一右  (对任一结点都先访问自己再访问左子树再访问右子树，为空则返回)<br>规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。<br>如下图，遍历的顺序为：ABDGHCEIF</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.jpg" alt="树"></p>
<p>2.中序遍历  左一根一右  (对任一结点都先访问左子树再访问自己再访问右子树，为空则返回)<br>规则是若树为空，则空操作返回，否则从根结点开始(注意并不是先访问根结点)，中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。顺序为：GDHBAEICF</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.jpg" alt="树"></p>
<p>3.后序遍历  左一右一根  (对任一结点都要先访问左子树再访问右子树再访问自己，为空则返回)<br>规则是若树为空，则空操作返回，否则从左到右从叶子结点开始的方式遍历访问左右子树，最后是访问根结点。<br>顺序为：GHDBIEFCA</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.jpg" alt="树"></p>
<p>4.层序遍历<br>规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。顺序为ABCDEFGHI</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.jpg" alt="树"></p>
<p>为什么要研究这么多遍历的方法呢？<br>我们用图形的方式来表现树的结构，应该说是非常直观和容易理解，但是对于计算机来说，它只有循环、判断等方式来处理，也就是说，它只会处理线性序列，而我们刚才提到的四种遍历方法，其实都是在树中的结点变成某种意义的线性序列，而这就给程序的实现带来了好处。</p>
<h4 id="前序遍历算法"><a href="#前序遍历算法" class="headerlink" title="前序遍历算法"></a>前序遍历算法</h4><p>二叉树的定义是用递归的方式，所以，实现遍历算法也可以采用递归，而且极其简单明了。先来看看二叉树的前序遍历算法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BitTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; T-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">//显示结点数据，可以更改为其他对结点的操作</span></span><br><span class="line">    PreOrderTraverse(T-&gt;lchild); <span class="comment">//先遍历左子树</span></span><br><span class="line">    PreOrderTraverse(T-&gt;rchild); <span class="comment">//在遍历后字数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>假设我们有下图这样一棵二叉树T。这树已经用二叉链表结构存储在内存当中。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%861.jpg" alt="树"></p>
<p>接下来我们来详细分解当调用函数PreOrderTraverse时，程序是如何运行的。</p>
<p>1.调用PreOrderTraverse(T)，T根结点不为null，所以打印字母A，调用PreOrderTraverse(T-&gt;lchild)，访问A结点的左孩子不为null，打印字母B，此时再次递归调用PreOrderTraverse(T-&gt;lchild)，再访问B的左孩子打印字母D，在访问D的左孩子打印字母H</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%862.jpg" alt="树"></p>
<p>2.再次递归调用PreOrderTraverse(T-&gt;lchild)，访问H结点的左孩子，此时因为H结点无左孩子，所以T=null，返回此函数(由于调用栈记住了函数的未完成状态，所以接着从函数调用递归之后的位置开始进行)，此时递归调用PreOrderTraverse(T-&gt;rchild)，访问了H结点的右孩子，打印字母K</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%863.jpg" alt="树"></p>
<p>3.再次递归调用PreOrderTraverse(T-&gt;lchild)，访问了K结点的左孩子，K结点无左孩子，返回，调用PreOrderTraverse(T-&gt;rchild)，访问了结点K的右孩子，也是null，返回。于是次函数执行完毕，返回到上一级递归的函数(即打印结点H时的函数)，也执行完毕，返回到打印结点D时的函数，调用PreOrderTraverse(T-&gt;rchild)，访问了结点D的右孩子，不存在，返回到B结点，调用PreOrderTraverse(T-&gt;rchild)，找到了结点E，打印字母E</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%864.jpg" alt="树"></p>
<p>4.由于结点E没有左右孩子，返回打印结点B时的递归函数，递归执行完毕，返回到最初的函数，调用PreOrderTraverse(T-&gt;rchild)，访问结点A的右孩子，打印字母C</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%865.jpg" alt="树"></p>
<p>5.之后类似前面的递归调用，依次继续打印F、I、G、J<br>综上所述，前序遍历这棵二叉树的节点顺序是：ABDHKECFIGJ</p>
<h4 id="中序遍历算法"><a href="#中序遍历算法" class="headerlink" title="中序遍历算法"></a>中序遍历算法</h4><p>那么二叉树的中序遍历算法又是如何呢？其实也没有很复杂，它和前序遍历算法仅仅只是代码的顺序上的差异</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    InOrderTraverse(T-&gt;lchild); <span class="comment">//中序遍历左子树</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; T-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">//显示结点数据</span></span><br><span class="line">    InOrderTraverse(T-&gt;rchild); <span class="comment">//中序遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>换句话说，它等于是把调用左孩子的递归函数提前了，就这么简单。</p>
<p>1.调用InOrderTraverse(T)，T的根结点不为null，于是调用InOrderTraverse(T-&gt;lchild)，访问结点B。当前指针不为null，继续调用InOrderTraverse(T)，访问结点D。不为null，继续调用InOrderTraverse(T-&gt;lchild)，访问结点H，访问结点H的左孩子，发现为null，于是返回此函数，打印当前结点H</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%861.jpg" alt="树"></p>
<p>2.然后调用InOrderTraverse(T-&gt;rchild)，访问结点H的右孩子K，因结点K无左孩子，所以打印K</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%862.jpg" alt="树"></p>
<p>3.因为结点K没有右孩子，函数结束，返回，而上一级结点H函数也执行完毕了，所以在此返回，打印字母D</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%863.jpg" alt="树"></p>
<p>4.结点D无右孩子，此函数执行完毕，返回。打印字母B</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%864.jpg" alt="树"></p>
<p>5.调用InOrderTraverse(T-&gt;rchild)，访问结点B的右孩子E，因结点E无左孩子，故打印E</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%865.jpg" alt="树"></p>
<p>6.结点E无右孩子，返回。结点B的递归函数也执行完毕，返回到了最初我们调用InOrderTraverse的地方，打印字母A</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%866.jpg" alt="树"></p>
<p>7.再调用InOrderTraverse(T-&gt;rchild)，访问结点A的右孩子C，再递归访问结点C的左孩子F，结点F的左孩子I，因为I无左孩子，打印I，之后分别打印F、C、G、J<br>综上，中序遍历这棵二叉树的结点顺序是：HKDBEAIFCGJ</p>
<h4 id="后序遍历算法"><a href="#后序遍历算法" class="headerlink" title="后序遍历算法"></a>后序遍历算法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    InOrderTraverse(T-&gt;lchild); <span class="comment">//后序遍历左子树</span></span><br><span class="line">    InOrderTraverse(T-&gt;rchild); <span class="comment">//后序遍历右子树</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; T-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">//显示结点数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>后序遍历是先递归左子树，由根结点A-&gt;B-&gt;D-&gt;H，结点H无左孩子，再查看结点H的右孩子K，因为结点K无左右孩子，所以打印K返回。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%861.jpg" alt="树"></p>
<p>最终，后序遍历的结点的顺序是：KHDEBIFJGCA(直到某结点的左右孩子都遍历完成再打印它自己)</p>
<h4 id="推导遍历结果"><a href="#推导遍历结果" class="headerlink" title="推导遍历结果"></a>推导遍历结果</h4><p>有一种题目为了考查你对二叉树遍历的掌握程度，是这样出题的。已知一棵二叉树的前序遍历序列为ABCDEF，中序遍历序列为CBAEDF，请问这棵二叉树的后序遍历结果是多少？</p>
<p>三种遍历都是从根结点开始，前序遍历是先打印再递归做和右。所以前序遍历序列为ABCDEF，第一个被打印出来的是A，所以A对应的是根结点。再由中序遍历序列是CBAEDF，可以知道C和B是A的左子树结点，E、D、F是A的右子树结点。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C1.jpg" alt="树"></p>
<p>然后我们看前序中的C和B，它的顺序是ABCDEF，是先打印B后打印C，所以B应该是A的左孩子，而C就只能是B的孩子，此时是左还是右不确定。再看看中序序列是CBAEDF，C是在B的前面打印，这就说明C是B的左孩子。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C2.jpg" alt="树"></p>
<p>在看前序中的E、D、F，它的顺序是ABCDEF，那就意味着D是A结点的右孩子，E和F是D的子孙，注意，它们中有一个不一定是孩子，还有可能是孙子的。再看中序序列是CBAEDF，由于E在D的左侧，而F在右侧，所以可以确定E是D的左孩子，F是D的右孩子。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C3.jpg" alt="树"></p>
<p>已经复原了二叉树没要得到后序遍历结果易如反掌，结果是CBEFDA。</p>
<p>我们可以得到两个二叉树遍历的性质。<br>1.已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树<br>2.已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树</p>
<p>注意，已知前序和后序遍历，是不能确定一棵二叉树的。</p>
<h4 id="层序遍历算法"><a href="#层序遍历算法" class="headerlink" title="层序遍历算法"></a>层序遍历算法</h4><p>从上到下，从左到右</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;TreeNode*&gt; q <span class="comment">//定义一个队列，数据类型是二叉树指针</span></span><br><span class="line">q.push(root);</span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> size=q.size();</span><br><span class="line">    <span class="comment">//使用size是可以将这一层的结点进行操作，而不用进入下一层</span></span><br><span class="line">    <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    TreeNode* front = q.front();</span><br><span class="line">    q.pop();                  <span class="comment">//删除最前面的节点</span></span><br><span class="line">    <span class="keyword">if</span> (front-&gt;left != <span class="literal">nullptr</span>) <span class="comment">//判断最前面的左节点是否为空，不是则放入队列</span></span><br><span class="line">        q.push(front-&gt;left);  </span><br><span class="line">    <span class="keyword">if</span> (front-&gt;right != <span class="literal">nullptr</span>)<span class="comment">//判断最前面的右节点是否为空，不是则放入队列</span></span><br><span class="line">        q.push(front-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;TreeNode&gt;q=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">q.add(root);</span><br><span class="line"><span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">  <span class="keyword">int</span> size=q.size();</span><br><span class="line">  <span class="comment">//使用size是可以将这一层的结点进行操作，而不用进入下一层</span></span><br><span class="line">  <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    TreeNode temp=q.poll();</span><br><span class="line">    <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="comment">//判断左子结点是否为空</span></span><br><span class="line">      q.add(temp.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="comment">//判断右子结点是否为空</span></span><br><span class="line">      q.add(temp.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的建立"><a href="#二叉树的建立" class="headerlink" title="二叉树的建立"></a>二叉树的建立</h3><p>说了半天，我们如何在内存中生成一棵二叉链表的二叉树呢？树都没有，哪来的遍历，所以我们还得谈谈关于二叉树的建立的问题</p>
<p>如果我们要在内存中建立一个如下图的二叉树<br><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B1.jpg" alt="树"></p>
<p>为了能够让每个结点确认是否有左右子结点，我们对它进行了扩展，变成下图的样子<br><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B2.jpg" alt="树"></p>
<p>也就是将二叉树中每个结点的空指针引出一个虚结点，其值为一特定值，比如”#”。我们称这种处理后的二叉树为原二叉树的扩展二叉树。扩展二叉树就可以做到一个遍历序列确定一棵二叉树了。比如上述二叉树的前序遍历就为AB#D##C##</p>
<h4 id="顺序结构建立二叉树"><a href="#顺序结构建立二叉树" class="headerlink" title="顺序结构建立二叉树"></a>顺序结构建立二叉树</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*构建二叉树*/</span></span><br><span class="line">    BinaryTree* s_arr[<span class="number">6</span>];</span><br><span class="line">    s_arr[<span class="number">0</span>] = <span class="keyword">new</span> BinaryTree(<span class="number">0</span>);</span><br><span class="line">    s_arr[<span class="number">1</span>] = <span class="keyword">new</span> BinaryTree(<span class="number">1</span>);</span><br><span class="line">    s_arr[<span class="number">2</span>] = <span class="keyword">new</span> BinaryTree(<span class="number">2</span>);</span><br><span class="line">    s_arr[<span class="number">3</span>] = <span class="keyword">new</span> BinaryTree(<span class="number">3</span>);</span><br><span class="line">    s_arr[<span class="number">4</span>] = <span class="keyword">new</span> BinaryTree(<span class="number">4</span>);</span><br><span class="line">    s_arr[<span class="number">5</span>] = <span class="keyword">new</span> BinaryTree(<span class="number">5</span>);</span><br><span class="line">    s_arr[<span class="number">0</span>]-&gt;left = s_arr[<span class="number">1</span>];  <span class="comment">//   0</span></span><br><span class="line">    s_arr[<span class="number">0</span>]-&gt;right = s_arr[<span class="number">2</span>]; <span class="comment">//  1  2</span></span><br><span class="line">    s_arr[<span class="number">1</span>]-&gt;left = s_arr[<span class="number">3</span>];  <span class="comment">// 3     5</span></span><br><span class="line">    s_arr[<span class="number">3</span>]-&gt;left = s_arr[<span class="number">4</span>];  <span class="comment">//4</span></span><br><span class="line">    <span class="comment">// new出来的最后记得释放内存</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg" alt="树"></p>
<h4 id="连式结构建立二叉树"><a href="#连式结构建立二叉树" class="headerlink" title="连式结构建立二叉树"></a>连式结构建立二叉树</h4><p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg" alt="树"></p>
<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><h3 id="哈夫曼树及其应用"><a href="#哈夫曼树及其应用" class="headerlink" title="哈夫曼树及其应用"></a>哈夫曼树及其应用</h3><p>先来了解几个概念<br>结点间路径长度(Path Length)：为连接两结点的路径上的分支数<br>结点的路径长度：从根结点到该结点的路径上分支的数目<br>树的路径长度：树中每个结点的路径长度之和<br>树的带权路径长度(Weighted Path Length,WPL)：树的各叶结点所带的权值与该结点到根的路径长度的乘积的和</p>
<h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><p>哈夫曼树：在所有含n个叶子结点、并带相同权值的m叉树中，必存在一棵其带权路径长度取最小值的树，称为“最优树”,或“哈夫曼树” (Huffman Tree)<br>WPL计算方法<br><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%91%E7%9A%84%E5%B8%A6%E6%9D%83%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6%E4%B8%BE%E4%BE%8B.jpg" alt="树"></p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>1.根据给定的 n 个权值 {w1, w2, …, wn}，构造 n 棵二叉树的集合F = {T1, T2, … , Tn}<br>2.在 F 中选取其根结点的权值为最小的两棵二叉树，分别作为左、右子树构造一棵新的二叉树，并置这棵新的二叉树根结点的权值为其左、右子树根结点的权值之和<br>3.从F中删去这两棵树，同时加入刚生成的新树<br>4.重复 (2) 和 (3) 两步，直至 F 中只含一棵树为止</p>
<h3 id="总结回顾-4"><a href="#总结回顾-4" class="headerlink" title="总结回顾"></a>总结回顾</h3><p>开头我们提到了树的定义，讲到了递归在树定义中的应用。提到了如子树、结点、度(子树数量)、叶子结点(度为0)、分支节点(度不为0)、父结点、子结点、层次(不同教材不同说法，根结点有认为是1层，也有认为是0层)、深度(最大层次(从1层开始))、森林等诸多概念，这些都是需要在理解的基础上去记忆的。</p>
<p>我们谈到了树的存储结构时，讲了双亲表示法，孩子表示法，孩子兄弟表示法等不同的存储结构。并由孩子兄弟表示法引出了我们这章最重要的一种树————二叉树。</p>
<p>二叉树的每个结点最多两棵子树，有左右之分。提到了斜树，满二叉树、完全二叉树等特殊二叉树的概念。</p>
<p>我们接着谈到了它的各种性质，这些性质给我们研究二叉树带来了方便。</p>
<p>二叉树的存储结构由于其特殊性使得既可以用顺序存储结构又可以用链式存储结构表示。</p>
<p>遍历是二叉树中一门重要的学问，前序、中序、后序以及层序遍历都是需要熟练掌握的知识。要让自己学会用计算机的运行思维去模拟递归的实现，可以加深我们对递归的理解。不过，并非二叉树遍历一定要用到递归，只不过递归的实现比较优雅而已。这点需要明确。</p>
<p>二叉树的建立自然也是可以通过递归来实现。</p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>图：图是由顶点的有穷非空集合和顶点之间边的集合组成，通常为：G(V,E)，其中 G 表示一个图，V是图 G 中顶点的集合，E是图 G 中边的集合。</p>
<h3 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h3><p>在线性表中，数据元素之间是被串起来的，仅有线性关系，每个数据元素只有一个直接前驱和一个直接后继。在树形结构中，数据元素之间有着明显的层次关系，并且每一层上的数据元素可能和下一层中多个元素相关，但只能和上一层中一个元素相关。这和一对父母可以有多个孩子，而每个孩子却只能有一对父母是一个道理。<br>图是一种较线性表和树更加复杂的数据结构。在图形结构中，结点之间的关系可以是任意的、图中任意两个数据元素之间都可能相关。</p>
<p>注意以下几点：</p>
<p>线性表中我们把数据元素叫元素，树中将数据元素叫结点，在图中数据元素，我们称之为顶点。</p>
<p>线性表中可以没有数据元素，称为空表。树中可以没有结点，叫做空树。然而在图结构中，不允许没有顶点。在定义中，若 V 是顶点的集合，则强调了顶点集合 V 有穷非空。</p>
<p>在线性表中，相邻的数据元素之间具有线性关系，树结构中，相邻两层的结点具有层次关系，而图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。(顶点之间可能没有关系)</p>
<h4 id="各种图定义"><a href="#各种图定义" class="headerlink" title="各种图定义"></a>各种图定义</h4><p><strong>无向边：若顶点v<sub>i</sub> 到 v<sub>j</sub> 之间的边没有方向，则称这条边为无向边(Edge)。</strong><br>用无序偶对(v<sub>i</sub>,v<sub>j</sub>) 来表示。如果图中任意两个顶点之间的边都是无向边，则称该图为无向图。如下</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%97%A0%E5%90%91%E5%9B%BE.jpg" alt="图"><br>由于是无方向的，连接顶点A与D的边，可以表示成无序对(A,D),也可以写成(D,A)<br>对于上图中的无向图G1来说，G1=(V1,{E1})，其中顶点集合 V1={A,B,C,D};边集合 E1={(A,B),(B,C),(C,D),(D,A),(A,C)}</p>
<p><strong>有向边：若从顶点v<sub>i</sub> 到 v<sub>j</sub>的边有方向，则称这条边为有向边，也称为弧(Arc)。</strong><br>用有序偶对&lt;v<sub>i</sub>,v<sub>j</sub>&gt;，v<sub>i</sub>称为弧尾(Tail)，v<sub>j</sub>称为弧头(Head)。如果图中任意两个顶点之间的边都是有向边，则称该图为有向图，下图为一有向图</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9C%89%E5%90%91%E5%9B%BE.jpg" alt="图"><br>连接顶点A到D的有向边就是弧，A是弧尾，D是弧头，&lt;A,D&gt;表示弧，注意不能写成&lt;D,A&gt;<br>对于上图中的有向图G2来说，G2=(V2,{E2})，其中顶点集合 V1={A,B,C,D};边集合 E1={&lt;A,D&gt;,&lt;B,A&gt;,&lt;C,A&gt;,&lt;B,C&gt;}</p>
<p>注意，无向边用小括号()表示，而有向边则是用尖括号&lt;&gt;表示。</p>
<p>在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图。我们课程里要讨论的都是简单图</p>
<p>在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。含有n个顶点的无向完全图有n*(n-1)/2条边</p>
<p>在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。含有n个顶点的有向完全图有n*(n-1)条边</p>
<p>有较少条边或弧的图称为稀疏图，反之称为稠密图。</p>
<p>有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权。这些权可以表示从一个顶点到另一个顶点的距离或耗费。这种带权的图通常称为网。<br><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BD%91.jpg" alt="图"></p>
<p>若一个图的点集和边集均为另一个图的子集，则称该图为另一图的子图</p>
<h4 id="图的顶点与边间的关系"><a href="#图的顶点与边间的关系" class="headerlink" title="图的顶点与边间的关系"></a>图的顶点与边间的关系</h4><p>对于无向图G=(V,{E})，如果边(v,v1)属于E，则称顶点v和v1互为邻接点，即v和v1相邻接。边(v,v1)依附于顶点v和v1，或者说(v,v1)与顶点v和v1相关联。顶点v的度是和v相关联的边的数目，记为TD(v)。</p>
<p>对于有向图G=(V,{E})，如果弧&lt;v,v1&gt;属于E，则称顶点v邻接到v1，顶点v1邻接自顶点v。弧&lt;v,v1&gt;与顶点v和v1相关联。以顶点v为头的弧的数目称为v的入度(进入这个点的弧的数量)，记为ID(v);以v为尾的弧的数目称为v的出度(从这个点出来的弧的数量)，记为OD(v);顶点v的度为TD(v)=ID(v)+OD(v)</p>
<p>路径的长度是路径上的边或弧的数目。</p>
<p>第一个顶点到最后一个相同顶点的路径称为回路或环。序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。</p>
<p>下图左边为简单环，右边不是简单环<br><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BD%91.jpg" alt="图"></p>
<h4 id="连通图相关术语"><a href="#连通图相关术语" class="headerlink" title="连通图相关术语"></a>连通图相关术语</h4><p>在无向图G中，如果从顶点v到v1有路径(注意是路径，不用直接相连也行)，则称v和v1是连通的。如果对于图中任意两个顶点均连通。则称G是连通图</p>
<p>下图左边不是连通图，右边是连通图<br><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%BF%9E%E9%80%9A%E5%9B%BE.jpg" alt="图"></p>
<p>无向图中的极大连通子图(边最多的情况)称为连通分量。注意以下几点</p>
<p>要是子图<br>子图是要连通的<br>连通子图含有极大定点数<br>具有极大定点数的连通子图包含依附于这些顶点的所有边</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%BF%9E%E9%80%9A%E5%9B%BE2.jpg" alt="图"></p>
<p>上图中图1是一个无向非连通图，但它有两个连通分量，即图2和图3，而图4尽管是图1的子图，但它却并不满足连通子图的极大顶点数(图2满足)。因此它不是图1的无向图的连通分量。</p>
<p>在有向图G中，如果对于每一对v<sub>i</sub>、v<sub>j</sub>属于v、v<sub>i</sub>!=v<sub>j</sub>，从v<sub>i</sub>到v<sub>j</sub>和从v<sub>j</sub>到v<sub>i</sub>都存在路径，则称G是强连通图。有向图中的极大强连通子图称作有向图的强连通分量。</p>
<p>连通图的生成树：<br>一个连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%94%9F%E6%88%90%E6%A0%91.jpg" alt="图"><br>上图中图2和图3都是一棵生成树，其他则不是。</p>
<p>如果一个有向图恰有一个顶点的入度为0，其余顶点入度均为1，则是一棵有向树。</p>
<h4 id="图的定义与术语总结"><a href="#图的定义与术语总结" class="headerlink" title="图的定义与术语总结"></a>图的定义与术语总结</h4><p>届于和图有关的定义和术语实在是太多了，在此整理一下。</p>
<p>图按照有无方向分为<strong>无向图</strong>和<strong>有向图</strong>。无向图由顶点和边构成，有向图由顶点和弧构成。弧有弧尾和弧头之分。</p>
<p>图按照边或弧的多少可以分为<strong>稀疏图</strong>和<strong>稠密图</strong>。如果任意两个顶点之间都存在边则称该图为<strong>完全图</strong>，有向的叫<strong>有向完全图</strong>。若无重复的边或顶点到自身的边则叫<strong>简单图</strong>。</p>
<p>图中顶点之间有<strong>邻接点</strong>、<strong>依附</strong>的概念。无向图顶点的边数叫做度，有向图顶点分为入度和出度。</p>
<p>图上的边或弧上带<strong>权</strong>则称为<strong>网</strong>。</p>
<p>图中顶点间存在<strong>路径</strong>，两顶点存在路径则说明是<strong>连通</strong>的，如果路径最终回到起始点则称为<strong>环</strong>，当中不重复叫<strong>简单路径</strong>。若任意两顶点都是连通的，则图就是<strong>连通图</strong>，有向则称<strong>强连通图</strong>。图中有子图，若子图极大连通则就是<strong>连通分量</strong>，有向的则称<strong>强连通分量</strong>。</p>
<p>无向图中连通且n个顶点n-1条边叫<strong>生成树</strong>。有向图中一顶点入度为0其余顶点入度为1的叫<strong>有向树</strong>。一个有向图由若干棵有向树构成<strong>生成森林</strong>。</p>
<h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><h4 id="邻接矩阵-数组"><a href="#邻接矩阵-数组" class="headerlink" title="邻接矩阵(数组)"></a>邻接矩阵(数组)</h4><p>考虑到图是有顶点和边或弧两部分组成，合在一起比较困难，那就很自然地考虑到分两个结构来分别存储。顶点不分大小、主次，所以用一个一维数组来存储是很不错的选择。而边或弧由于是顶点与顶点之间的关系，一维搞不定，那就考虑用一个二维数组来存储。于是我们的邻接矩阵的方案就诞生了。</p>
<p>图的邻接矩阵存储方式使用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组(称为邻接矩阵)存储图中的边或弧的信息。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.jpg" alt="图"></p>
<hr>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AE%9E%E4%BE%8B.jpg" alt="图"></p>
<p>简单解释一下，对于矩阵的主对角线的值，即arc[0][0]、arc[1][1]、arc[2][2]、arc[3][3]，全为0是因为不存在顶点到自身的边，比如v0到v0。arc[0][1]=1是因为v0到v1的边存在，而arc[1][3]=0是因为v1到v3的边不存在。并且由于是无向图，v1到v3的边不存在，意味着v3到v1的边也不存在。所以无向图的边数组是一个对称矩阵。</p>
<p>嗯？对称矩阵是什么？忘记了不要紧，复习一下。所谓对称矩阵就是n阶矩阵的元素满足a<sub>ij</sub>=a<sub>ji</sub>，(0&lt;=i，j&lt;=n)。即从矩阵的左上角到右下角的主对角线为轴，右上角的元素与左下角相对应的元素全都是相等的，表现出来就是关于主对角线对称。</p>
<p>我们再来看一个有向图案例<br><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AE%9E%E4%BE%8B1.jpg" alt="图"></p>
<p>由于是有向图，所以此矩阵并不对称，有向图讲究出度与入度</p>
<p>　　在有向图中, 统计第i行 1 的个数可得顶点 vi 的出度，统计第j列 1 的个数可得顶点 vj 的入度<br>　　在无向图中, 统计第i 行 (列) 1 的个数可得顶点 vi 的度</p>
<p>在图的术语中，我们提到了网的概念，也就是每条边上带有权的图叫做网。那么这些权值就需要存下来。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%9A%84%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.jpg" alt="图"></p>
<p>这里wij 表示(vi,vj) 或&lt;vi,vj&gt; 上的权值。∞表示一个计算机允许的、大于所有边上权值的值，也就是一个不可能的极限值。有同学会问，为什么不是0呢？原因在于权值wij大多数情况下是正值，但个别时候可能就是0，甚至有可能是负值。因此必须要用一个不可能的值来表示其不存在。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%9A%84%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AE%9E%E4%BE%8B.jpg" alt="图"></p>
<h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>邻接矩阵是不错的一种图存储结构，但是我们也发现，对于边数相对顶点较少的图，这种结构是存在对存储空间的极大浪费的。比如我们要处理下图这样的稀疏有向图。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%82%BB%E6%8E%A5%E8%A1%A81.jpg" alt="图"></p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%82%BB%E6%8E%A5%E8%A1%A82.jpg" alt="图"><br>邻接矩阵中除了arc[1][0]有权值外，没有其他弧，其实这些存储空间都浪费掉了。</p>
<p>因此我们考虑使用链式存储的结构。我们把这种数组和链表相结合的存储方法称为邻接表。</p>
<p>邻接表的处理办法是这样。<br>1、图中顶点用一个一维数组存储。<br>2、图中每个顶点vi的所有邻接点构成一个线性表，由于邻接点的个数不定，所以用单链表存储，无向图称为顶点vi 的边表，有向图则称为顶点vi 作为弧尾的出边表。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%82%BB%E6%8E%A5%E8%A1%A83.jpg" alt="图"></p>
<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>图的遍历和树的遍历类似，我们希望从图中某一顶点出发访遍图中其余顶点，且每一个顶点仅被访问一次，这一过程就叫做图的遍历。</p>
<h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><p>深度优先遍历，也可称为深度优先搜索，简称为DFS</p>
<p>假设给定图G的初态是所有顶点均未曾访问过。在G中任选一顶点v为初始出发点(源点)，则深度优先遍历可定义如下：首先访问出发点v，并将其标记为已访问过；然后依次从v出发搜索v的每个邻接点w。若w未曾访问过，则以w为新的出发点继续进行深度优先遍历，直至图中所有和源点v有路径相通的顶点(亦称为从源点可达的顶点)均已被访问为止。若此时图中仍有未访问的顶点，则另选一个尚未访问的顶点作为新的源点重复上述过程，直至图中所有顶点均已被访问为止。(就是不停的往里钻)</p>
<p>说白了深度优先遍历就是一种不撞南墙不会头的算法，他会把一条路走完之后再回溯到有分叉的节点继续遍历。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.jpg" alt="图"></p>
<p>深度优先遍历其实就是一个递归的过程，它就像是一棵树的前序遍历，它从图中某个顶点v出发，访问该顶点，然后从v的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径连通的顶点都被访问到。</p>
<h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><p>从图中某个顶点V0出发，并访问此顶点；</p>
<p>从V0出发，访问V0的各个未曾访问的邻接点W1，W2，…,Wk;然后,依次从W1,W2,…,Wk出发访问各自未被访问的邻接点；<br>重复步骤，直到全部顶点都被访问为止。(铺开来访问)</p>
<p>这是一种层层递进的算法，与树的层序遍历类似。</p>
<p>在广度优先搜索时，会从起点开始“一层一层”扩展的方法来遍历，扩展时每发现一个点就将这个点加入到队列，直到整张图都被遍历过位置。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.jpg" alt="图"></p>
<p>如果说图的深度优先遍历类似树的前序遍历，那么图的广度优先遍历就类似树的层序遍历了。</p>
<p>对比图的深度优先遍历与广度优先遍历算法，你会发现，它们在时间复杂度上是一样的，不同之处仅仅在于对顶点访问的顺序不同。可见二者在全图遍历上是没有优劣之分的，只是视不同的情况选择不同的算法。</p>
<p>对于n各顶点e条边的图来说，邻接矩阵深度优先算法时间复杂度为O(n<sup>2</sup>)，而邻接表做存储结构时，时间复杂度是O(n+e)，广度优先算法同上</p>
<p>不过如果图的顶点和边非常多，不能再短时间内遍历完成，遍历的目的是为了寻找合适的顶点，那么深度优先更适合目标比较明确，以找到目标为主要目的的情况，而广度优先则更适合在不断扩大遍历范围时找到最优解的情况</p>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>我们把构造连通网的最小代价生成树成为最小生成树。</p>
<p>所谓最小代价，就是n个顶点用n-1条边把一个连通图连接其阿里，并且使得权值的和最小。(树是边数最少的连通图)</p>
<h4 id="普里姆-Prim-算法"><a href="#普里姆-Prim-算法" class="headerlink" title="普里姆 (Prim) 算法"></a>普里姆 (Prim) 算法</h4><p>这是确定点来找边的算法<br>(1)取图中任意一个顶点 v 作为生成树的根，之后往生成树上添加新的顶点<br>(2)在生成树的构造过程中，网中 n  个顶点分属两个集合：已落在生成树上的顶点集 U 和尚未落在生成树上的顶点集V-U ，则应在所有连通U中顶点和V-U中顶点的边中<strong>选取权值最小的边</strong>(u,v)这里u属于U，v属于V-U，将v添加到U中<br>(3)重复（2）继续往生成树上添加顶点，直至生成树上含有 n个顶点为止</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%99%AE%E9%87%8C%E5%A7%86%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B.jpg" alt="图"></p>
<p>时间复杂度为O(n<sup>2</sup>)</p>
<h4 id="克鲁斯卡尔（Kruskal）算法"><a href="#克鲁斯卡尔（Kruskal）算法" class="headerlink" title="克鲁斯卡尔（Kruskal）算法"></a>克鲁斯卡尔（Kruskal）算法</h4><p>这是确定边来找点的算法<br>考虑问题的出发点: 为使生成树上边的权值之和达到最小，则应使生成树中每一条边的权值尽可能地小</p>
<p>具体做法: 先构造一个只含 n 个顶点的子图 SG，然后从权值最小的边开始，若它的添加不使SG 中产生长度大于2的简单回路(环)，则在 SG 上加上这条边，如此重复，直至加上 n-1 条边为止</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B.jpg" alt="图"></p>
<p>会用就行，程序不要求(程序难点在于判断是否会产生回路很难)</p>
<p>此算法的复杂度由边数e决定，克鲁斯卡尔算法的时间复杂度为O(eloge)</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>上述两种算法均为贪心算法。</p>
<p>普里姆算法是从任意一个点开始，找权值最小的边，然后一直找权值最小的边直到所有点都找齐<br>克鲁斯卡尔算法是直接找最小的边，然后一直找边，但有个前提，这些边不能构成回路，直到完成。</p>
<p>对比两个算法，克鲁斯卡尔算法主要是针对边展开，边数少的时候效率会非常高，所以对于稀疏图有很大优势<br>而普里姆算法对于稠密图，即边数非常多的情况会更好一些</p>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>有向无环的图及应用，可判断图有无环</p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>按照有向图给出的次序关系，将图中顶点排成一个线性序列，对于有向图中没有限定次序关系的顶点，则可以人为加上任意的次序关系<br>由此所得顶点的线性序列称之为拓扑有序序列<br>(拓扑排序的答案不是唯一的)</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F1.jpg" alt="图"></p>
<p>可求得拓扑有序序列：ABCD 或 ACBD</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F2.jpg" alt="图"></p>
<p>不能求得它的拓扑有序序列<br>因为图中存在一个回路 {B, C, D}</p>
<h4 id="进行步骤"><a href="#进行步骤" class="headerlink" title="进行步骤"></a>进行步骤</h4><p>(1)从有向图中选取一个没有前驱的顶点，并输出之<br>(2)从有向图中删去此顶点以及所有以它为起点的边<br>重复上述两步，直至图空，或者图不空但找不到无前驱的顶点为止</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F3.jpg" alt="图"></p>
<h4 id="在算法中需要用定量的描述替代定性的概念"><a href="#在算法中需要用定量的描述替代定性的概念" class="headerlink" title="在算法中需要用定量的描述替代定性的概念"></a>在算法中需要用定量的描述替代定性的概念</h4><p>没有前驱的顶点 等效于 入度为零的顶点<br>删除顶点及以它为起点的边 等效于 终点的入度减1</p>
<p>在算法中, 使用一个队列或栈存放入度为零的顶点,供选择和输出无前驱的顶点</p>
<h4 id="拓扑排序算法的描述"><a href="#拓扑排序算法的描述" class="headerlink" title="拓扑排序算法的描述"></a>拓扑排序算法的描述</h4><p>建立入度为零的顶点队列(或栈)<br>入度为零的队列(或栈)不空时, 重复执行<br>1.从队列(或栈)中退出一个顶点, 并输出之<br>2.从有向图中删去这个顶点和它发出的边, 边的终点入度减一<br>3.如果边的终点入度减至0, 则该顶点进入入度为零的顶点队列(或栈)<br>如果输出顶点个数少于有向图的顶点个数, 则报告图中存在有向环</p>
<h4 id="拓扑排序的算法实现"><a href="#拓扑排序的算法实现" class="headerlink" title="拓扑排序的算法实现"></a>拓扑排序的算法实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TopSort</span><span class="params">(<span class="keyword">const</span> AdjMatrixDirGraph&lt;ElemType&gt; &amp;g)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 初始条件：存在有向图g</span></span></span><br><span class="line"><span class="function"><span class="comment">// 操作结果：如g无回路,则输出g的顶点的一个拓扑序列,</span></span></span><br><span class="line"><span class="function"><span class="comment">// 并返回true,否则返回false</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[g.GetVexNum()];<span class="comment">// 入度数组    LinkStack&lt;int&gt; temS;        // 栈</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;            <span class="comment">// 计数器</span></span><br><span class="line">    StatInDegree(g, inDegree);    <span class="comment">// 统计顶点的入度</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; g.GetVexNum(); v++)</span><br><span class="line">    &#123;    <span class="comment">// 遍历顶点</span></span><br><span class="line">        <span class="keyword">if</span> (inDegree[v] == <span class="number">0</span>)</span><br><span class="line">        &#123;    <span class="comment">// 建立入度为0的顶点栈</span></span><br><span class="line">            temS.Push(v);    <span class="comment">// 入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!temS.Empty())</span><br><span class="line">    &#123;    <span class="comment">// 栈非空</span></span><br><span class="line">        <span class="keyword">int</span> v1;</span><br><span class="line">        temS.Pop(v1);    <span class="comment">// 取出一个入度为0的顶点</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v1 &lt;&lt; <span class="string">&quot;  &quot;</span>;    <span class="comment">// 输出顶点</span></span><br><span class="line">        count++;        <span class="comment">// 对输出顶点进行记数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v2 = g.FirstAdjVex(v1); v2 != <span class="number">-1</span>; </span><br><span class="line">            v2 = g.NextAdjVex(v1, v2))</span><br><span class="line">        &#123;    <span class="comment">// 对v1的每个邻接v2入度减1</span></span><br><span class="line">            <span class="keyword">if</span> (--inDegree[v2] == <span class="number">0</span>)</span><br><span class="line">            &#123;    <span class="comment">// v2入度为0,将v2入栈</span></span><br><span class="line">                temS.Push(v2);    <span class="comment">// 入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> []inDegree;        <span class="comment">// 释放存储空间</span></span><br><span class="line">     <span class="keyword">if</span> (count &lt; g.GetVexNum()) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">// 图g有回路</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;        <span class="comment">// 拓扑排序成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><p>首先我们提出一个问题：<br>假设以有向网表示一个施工流程图，边表示活动，边上的权值表示完成该活动所需时间。<br>问：哪些活动 “关键活动”？<br>即：哪些活动将影响整个工程的完成期限</p>
<p>整个工程完成的时间为：从有向网的源点到汇点的最长路径的长度</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%841.jpg" alt="图"></p>
<p>最长的从头到尾那条</p>
<p>“关键活动”指的是：该边上的权值增加 将使有向网上的最长路径的长度增加<br>完成整个工程所需的时间取决于从源点到汇点的最长路径长度, 即在这条路径上所有活动的持续时间之和。这条路径长度最长的路径就叫做关键路径</p>
<p>要找出关键路径，必须找出关键活动，即不按期完成就会影响整个工程完成工期的活动，关键路径上的所有活动都是关键活动因此，只要找到了关键活动，就可以找到关键路径</p>
<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><p>最短路径问题:如果从有向网中某一顶点(称为源点)到达另一顶点(称为终点)的路径可能不止一条，如何找到一条路径使得沿此路径上各边上的权值总和达到最小</p>
<p>基础概念：<br>什么是源点？<br>路径起始的第一个顶点称为源点（Source），最后一个顶点称为终点（Destination<br><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%BA%90%E7%82%B9.jpg" alt="图"></p>
<p>上图中，我们用红色标注出的就可以认为是一个路径（v0-&gt;v1-&gt;v4-&gt;v6-&gt;v8）的源点和终点，但不要有误区，其实图中的任何一个顶点都可作为源点或者终点，源点与终点只是相对一条路径而言的。</p>
<hr>
<p>什么是最短路径？<br>对于无向图而言，从源点v0 到终点v8 的最短路径就是从源点v0 到终点v8 所包含的边最少的路径。我们只需要从源点v0出发对图做广度优先搜索，一旦遇到终点v8就终止。我们可以具体来看看如何得到无向图中源点v0 到终点v8 的最短路径。</p>
<h4 id="单源点最短路径问题——Dijkstra算法"><a href="#单源点最短路径问题——Dijkstra算法" class="headerlink" title="单源点最短路径问题——Dijkstra算法"></a>单源点最短路径问题——Dijkstra算法</h4><p>首先求出长度最短的一条最短路径，再参照它求出长度次短的一条最短路径，依次类推，直到从顶点vs到其它各顶点的最短路径全部求出为止(我不在乎我求出的路径的终点在哪，我只在乎我每一步求得的路径是不是长度次短的最短路径)</p>
<p>依最短路径的长度递增的次序求得各条路径<br><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%841.jpg" alt="图"><br>其中，从源点vs到顶点v1的最短路径是所有最短路径中长度最短者</p>
<p>创建距离表<br><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%B7%9D%E7%A6%BB%E8%A1%A81.jpg" alt="图"></p>
<p>其中dist[i]表示当前已求得的从源点vs到vi的最短路径长度，U={vs}, U1={},满足路径无中间点 ，即中间点属于集合U1，则最短的最短路径长度为：</p>
<p>dist[i1]=Min{dist[i]|vi∈V-U}<br>数学表达式{A|B}的意思是：表示集合A，A的取值表达式为B</p>
<p>第1步：找到从源点开始路径长度最短的最短路径：<br>在这条路径上，必定只含一条边（终点为vi1），并且这条边的权值最小。</p>
<p>第2步：找到下一条从源点开始路径长度次短的最短路径：<br>它只可能有两种情况：或者是直接从源点到该点vi2(只含一条边),路径为{vs, vi2}, 或者是从源点经过顶点vi1，再到达该顶点vi2(由两条边组成), 路径为{vs, vi1, vi2}，选择更小的那一条路径。<br>其中dist[i]表示当前已求得的从源点vs到vi的最短路径长度，U={vs,vi1}, U1=U–{vs}，满足路径上的中间点属于集合U1(空集也算)<br>dist[i2]=Min{dist[i1]+net.GetWeight(i1,i), dist[i2]}</p>
<p>第k步：第k条最短路径的特点：<br>这时，我要找出比k-1步路径大，而又小于其他所有未求得路径的那条路径，我们知道这条路径必然经过我们已经求出的那些已知最短路径的点，我们只需要求这些点到任意新顶点的路径，然后比较可得<br>其中dist[i]表示当前已求得的从源点vs到vi的最短路径长度,U={vs,vi1,…,vik-1},U1=U-{vs}, 满足路径上的中间点属于集合U1，则第k条最短路径长度为：dist[ik]=Min{dist[i]|vi∈V-U}</p>
<p>中间点必须属于集合U：由反证法，假设，vj不属于U1，那么vj就为最短路径未求得的点，而源点到vj的距离一定小于源点到vj到vk的距离，而我们要的是仅仅比已求得路径大而又小于其他路径的路径，所以这种情况不可能发生。</p>
<p>它并不是一下子就求出了v0到vn的最短路径，而是一步步求出它们之间顶点的最短路径，过程中都是基于已经求出的最短路径的基础上，求得更远顶点的最短路径，最终得到你要的结果。</p>
<h4 id="两顶点之间的最短路径——Floyd算法"><a href="#两顶点之间的最短路径——Floyd算法" class="headerlink" title="两顶点之间的最短路径——Floyd算法"></a>两顶点之间的最短路径——Floyd算法</h4><p>弗洛伊德算法的基本思想是：<br>从 vi 到 vj 的所有可能存在的路径中，选出一条长度最短的路径</p>
<p>开始(第-1步):若&lt;vi,vj&gt;存在,则存在路径{vi,vj} ，路径中不含其它顶点,相当于中间点属于集合U={}，其中D<sup>(-1)</sup>[i][j]表示从vi到vj的中间点属于集合U={}的最短路径长度。</p>
<p>第0步:若&lt;vi,v0&gt;,&lt;v0,vj&gt;存在，则存在路径{vi,v0,vj} ，路径中间点所含顶点序号不大于0, 相当于中间点属于集合U={v0}，其中D<sup>(0)</sup>[i][j]表示从vi到vj中间点属于集合U={v0}的最短路径的长度<br>其中D<sup>(0)</sup>[i][j]表示从vi到vj的中间点属于集合U={v0}的最短路径长度。</p>
<p>第1步:若存在路径{vi,…,v1}与 {v1,…,vj} ，则存在路径{vi,…,v1,…,vj} ，路径中间点所含顶点序号不大于1, 相当于中间点属于集合U={v0,v1}，其中D<sup>(1)</sup>[i][j]表示从vi到vj中间点属于集合U={v0,v1}的最短路径的长度<br>D<sup>(1)</sup>[i][j]=Min{D<sup>(1)</sup>[i][0]+D<sup>(1)</sup>[0][j]，D<sup>(1)</sup>[i][j]}<br>其中D<sup>(1)</sup>[i][j]表示从vi到vj中间点属于集合U={v0,v1}的最短路径的长度</p>
<p>第k步:若存在路径{vi,…,vk}和 {vk,…,vj} ，则存在路径{vi,…,vk,…,vj} ，路径中间点所含顶点序号不大于k, 相当于中间点属于集合U={v0,v1,…,vk}，其中D<sup>(k)</sup>[i][j]表示从vi到vj中间点属于集合U={v0,v1,…,vk}的最短路径的长度</p>
<p>第n-1步:若存在路径{vi,…,vn-1}和 {vn-1,…,vj} ，则存在路径{vi,…,vn-1,…,vj} ，路径中间点所含顶点序号不大于n-1, 相当于中间点属于集合U= {v0, v1, …, vn-1}=V，其中D<sup>(n-1)</sup>[i][j]表示从vi到vj中间点属于集合U={v0,v1,…,vn-1}=V的最短路径的长度，实际就是从vi到vj的最短路径的长度</p>
<p>先让从源点到终点路径都没有中间点，<br>再让路径都只能经过中间点v0，计算是否有最短路径变化<br>再让路径都只能经过中间点v0，v1，对比之前的看看路径是否变得更短了，没有则不变，有则替换其为最小<br>以此类推就这样一直到vn为止</p>
<h4 id="两种算法的异同"><a href="#两种算法的异同" class="headerlink" title="两种算法的异同"></a>两种算法的异同</h4><p>迪杰斯特拉算法是找最短路径，然后再找次短，然后再找次次短，就是从最短的开始，然后倒数第二短，一直到最长的路径，不断向外发散。它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。</p>
<p>弗洛伊德算法是先算两个点之间不经过任何点的最短距离(没有则记为无穷)，然后只能经过v0，或者不经过的最短距离(没有则记为无穷)，然后只能经过v0,v1，或者不经过的最短距离，以此类推求得将中间点扩张至vn时，就能求出源点到终点最短路径了</p>
<p>它们本质都是中间点不断扩张，然后从中间点出发找出源点与终点最短路径</p>
<p>上述两种算法时间复杂度均为O(n<sup>3</sup>)</p>
<h3 id="总结回顾-5"><a href="#总结回顾-5" class="headerlink" title="总结回顾"></a>总结回顾</h3><p>图的存储结构我们一共讲了两种——邻接表和邻接矩阵，它们分别代表着边集是用数组还是链表的方式存储。</p>
<p>图的遍历分为深度和广度两种，各有优缺点，就像人在追求卓越时是着重深度还是看重广度，总是很难说清楚。</p>
<p>图的应用是我们这一章浓墨重彩的一部分，一共谈了三种应用：最小生成树、最短路径和有向无环图的应用。</p>
<p>最小生成树，我们讲了两种算法：普里姆(Prim)算法和克鲁斯卡尔(Kruskal)算法。普利姆算法就像是走一步看一步的思维方式，逐步生成最小生成树。而克鲁斯卡尔算法则更有全局意识，直接从图中最短权值的边入手，搜寻最后的答案。</p>
<p>最短路径的现实应用非常多，我们也介绍了两种算法。迪杰斯特拉(Dijkstra)算法更强调单源顶点查找路径的方式。而弗洛伊德(Floyd)算法则完全抛开了单点的思维方式。</p>
<p>有向无环图时常应用于工程规划中，对于整个工程或系统来说，我们一方面关心的是工程能否顺利进行的问题，通过拓扑排序的方式，我们可以有效地分析出一个有向图是否存在环，如果不存在，那么它的拓扑排序是什么？另一方面关心的是整个工程完成所必须的最短时间问题，利用求关键路径的算法，可以得到最短完成工程的工期以及关键的活动有哪些。</p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="二叉排序树-二叉查找树"><a href="#二叉排序树-二叉查找树" class="headerlink" title="二叉排序树(二叉查找树)"></a>二叉排序树(二叉查找树)</h3><p>二叉排序树也称为二叉查找树，二叉排序树或者是一棵空树；或者是具有如下特性的二叉树<br>1.若它的左子树不空，则左子树上所有结点的值均小于根结点的值<br>2.若它的右子树不空，则右子树上所有结点的值均大于根结点的值<br>3.它的左、右子树也都分别是二叉排序树</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E4%B8%BE%E4%BE%8B.jpg" alt="查找"></p>
<h4 id="二叉排序树的查找算法"><a href="#二叉排序树的查找算法" class="headerlink" title="二叉排序树的查找算法"></a>二叉排序树的查找算法</h4><p>若二叉排序树为空，则查找不成功，否则:<br>1.若给定值等于根结点的值，则查找成功<br>2.若给定值小于根结点的值，则继续在左子树上进行查找<br>3.若给定值大于根结点的值，则继续在右子树上进行查找</p>
<p>如果对一棵二叉排序树进行中序遍历，可以按从小到大的顺序，将各结点的值排列起来</p>
<h3 id="平衡二叉树-AVL树"><a href="#平衡二叉树-AVL树" class="headerlink" title="平衡二叉树(AVL树)"></a>平衡二叉树(AVL树)</h3><h4 id="平衡二叉树的定义："><a href="#平衡二叉树的定义：" class="headerlink" title="平衡二叉树的定义："></a>平衡二叉树的定义：</h4><p>一棵AVL树或者是空树，或者是具有下列性质的二叉查找树：它的左子树和右子树都是AVL树，且每一个结点左子树和右子树的高度之差的绝对值不超过1<br><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91%E4%B8%BE%E4%BE%8B.jpg" alt="查找"></p>
<h4 id="平衡因子-balance-factor-："><a href="#平衡因子-balance-factor-：" class="headerlink" title="平衡因子 (balance factor)："></a>平衡因子 (balance factor)：</h4><p>每个结点附加一个数字, 给出该结点左子树的高度减去右子树的高度所得的高度差, 这个数字即为结点的平衡因子<br>AVL树任一结点平衡因子只能取-1, 0, 1</p>
<p>如果一个结点的平衡因子的绝对值大于1, 则这棵二叉查找树就失去了平衡,不再是AVL树<br>如果一棵二叉查找树是平衡的, 且有 n个结点，可证明其高度可保持在O(log2n),平均查找长度也可保持在O(log2n)</p>
<h4 id="平衡化旋转"><a href="#平衡化旋转" class="headerlink" title="平衡化旋转"></a>平衡化旋转</h4><p>如果在一棵平衡的二叉查找树中插入一个新结点，造成了不平衡。此时必须调整树的结构，使之平衡化<br>平衡化旋转有两类：单旋转 (左旋和右旋)、双旋转 (左旋加右旋和右旋加左旋)</p>
<h3 id="哈希表-Hash"><a href="#哈希表-Hash" class="headerlink" title="哈希表(Hash)"></a>哈希表(Hash)</h3><h4 id="散列表的概念"><a href="#散列表的概念" class="headerlink" title="散列表的概念"></a>散列表的概念</h4><p>以上讨论的表示查找表的各种结构的共同特点：记录在表中的位置和它的关键字之间不存在一个确定的关系</p>
<p>在一般情况下，需在关键字与记录在表中的存储位置之间建立一个函数关系，以 H(key) 作为关键字为 key 的记录在表中的位置，通常称这个函数 H(key) 为散列函数，也称为哈希函数<br><strong>H(key)是关键字，key是对应值</strong></p>
<p>哈希函数通过函数值是将关键字的 集合对应到某个地址集合上，它的设 置很灵活，只要这个地址集合的大小 不超出允许范围即可</p>
<p>很难找到一个不产生冲突的哈希函数。一般情况下，只能选择恰当的哈希函数，使冲突尽可能少地产生</p>
<h4 id="哈希表的定义"><a href="#哈希表的定义" class="headerlink" title="哈希表的定义"></a>哈希表的定义</h4><p>根据设定的哈希函数 H (key) 和所选处理冲突的方法，将一组关键字对应到一个有限的、地址连续的地址集(区间)上，并以关键字在地址集中的“对应值”作为相应记录在表中的存储位置，如此构造所得的查找表称为“哈希表”</p>
<h4 id="构造哈希函数的方法"><a href="#构造哈希函数的方法" class="headerlink" title="构造哈希函数的方法"></a>构造哈希函数的方法</h4><h5 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h5><p>以关键字的平方值的中间几位作为存储地址。平方值的中间各位又能受到整个关键字中各位的影响</p>
<h5 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h5><p>设定哈希函数为:H(key) = key % p<br>其中，p≤m (表长)并且p 最好为不大于 m 的素数或是不含 20 以下的质因子</p>
<h5 id="随机数法"><a href="#随机数法" class="headerlink" title="随机数法"></a>随机数法</h5><p>设定哈希函数为:H(key) = Random(key)<br>其中，Random()为伪随机函数</p>
<h4 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h4><h5 id="开放定址法-闭域法"><a href="#开放定址法-闭域法" class="headerlink" title="开放定址法(闭域法)"></a>开放定址法(闭域法)</h5><p>为产生冲突的地址 H(key) 求得一个地址序列：H0, H1, H2, …, Hs     1≤ s≤m-1<br>其中：H0 = H(key)<br>Hi = ( H(key) + di ) % m<br>i=1, 2, …, s</p>
<p>增量 di 的两种取法<br>1.线性探测再散列di = i<br>2.随机探测再散列di 是一组伪随机数列</p>
<h5 id="链地址法-开域法"><a href="#链地址法-开域法" class="headerlink" title="链地址法(开域法)"></a>链地址法(开域法)</h5><p>将所有哈希值相同的记录都链接在同一链表中<br><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95.jpg" alt="查找"></p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>所有的简单排序方法（包括：直接插入、起泡和简单选择）和堆排序的空间复杂度即所需的辅助存储空间为O(1)</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h4 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h4><p>堆分为大顶堆和小顶堆</p>
<p>堆中结点内的数字就是存储的数据。堆中的每个结点最多有两个子结点。树的形状取决于数据的个数，另外结点的排列顺序为从上到下，同一行里则从左到右(层序遍历)</p>
<p>小顶堆<br><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B0%8F%E9%A1%B6%E5%A0%86%E4%B8%BE%E4%BE%8B.jpg" alt="堆"><br>子结点必定大于父结点。因此，最小值被存储在顶端的根结点中。</p>
<p>大顶堆<br>子结点必定小于父结点。因此，最大值被存储在顶端的根结点中。</p>
<h4 id="建堆、筛选"><a href="#建堆、筛选" class="headerlink" title="建堆、筛选"></a>建堆、筛选</h4><p>筛选法就是开始按现有的顺序从上到下，从左到右放到一个完全二叉树里面。然后把这个树调节成堆。调节的时候从最后一个有儿子的节点(非叶子结点)开始。 也就是从下往上，从右往左找，找到的第一个有孩子的节点开始。依次把各个节点及下面的孩子组成的树调节成堆。</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p>直接插入排序的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表<br><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F1.jpg" alt="排序"></p>
<h4 id="希尔-Shell-排序"><a href="#希尔-Shell-排序" class="headerlink" title="希尔(Shell)排序"></a>希尔(Shell)排序</h4><h5 id="希尔排序的思想"><a href="#希尔排序的思想" class="headerlink" title="希尔排序的思想"></a>希尔排序的思想</h5><p>希尔排序的基本思想：对待排元素序列先作“宏观”调整，再作“微观”调整。<br>(所谓“宏观”调整，指的是，“跳跃式”的插入排序。)</p>
<h5 id="希尔排序的实现方法"><a href="#希尔排序的实现方法" class="headerlink" title="希尔排序的实现方法"></a>希尔排序的实现方法</h5><p>将元素序列分成若干子序列，分别对每个子序列进行插入排序。</p>
<p>例如：将 n 个元素分成 d 个子序列：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;elem[<span class="number">0</span>]，elem[<span class="number">0</span>+d]，elem[<span class="number">0</span>+<span class="number">2</span>d]，…， elem[<span class="number">0</span>+kd] &#125;</span><br><span class="line">&#123;elem[<span class="number">1</span>]，elem[<span class="number">1</span>+d]，elem[<span class="number">1</span>+<span class="number">2</span>d]，…， elem[<span class="number">1</span>+kd] &#125;</span><br><span class="line">  …</span><br><span class="line">&#123;elem[d<span class="number">-1</span>], elem[<span class="number">2</span>d<span class="number">-1</span>], elem[<span class="number">3</span>d<span class="number">-1</span>], …, elem[(k+<span class="number">1</span>)d<span class="number">-1</span>]&#125;</span><br></pre></td></tr></table></figure>

<p>其中，d 称为增量，它的值在排序过程中从大到小逐渐缩小，直至最后一趟排序减为 1。</p>
<p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F1.jpg" alt="排序"><br>前面的值大于后面的就交换(交换过还满足条件就再交换一遍)</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/26/2020-08-25/" rel="prev" title="2020-08-25">
      <i class="fa fa-chevron-left"></i> 2020-08-25
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/10/23/%E9%80%92%E5%BD%92/" rel="next" title="递归">
      递归 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA"><span class="nav-number">1.</span> <span class="nav-text">数据结构绪论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD"><span class="nav-number">1.1.</span> <span class="nav-text">基本概念和术语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E5%92%8C%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.</span> <span class="nav-text">逻辑结构和物理结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.1.</span> <span class="nav-text">逻辑结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.2.</span> <span class="nav-text">物理结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.</span> <span class="nav-text">数据类型和抽象数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.1.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.2.</span> <span class="nav-text">抽象数据类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE"><span class="nav-number">1.4.</span> <span class="nav-text">总结回顾</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">2.1.</span> <span class="nav-text">算法的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%A6%81%E6%B1%82"><span class="nav-number">2.2.</span> <span class="nav-text">算法设计的要求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E7%9A%84%E5%BA%A6%E9%87%8F%E6%96%B9%E6%B3%95"><span class="nav-number">2.3.</span> <span class="nav-text">算法效率的度量方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E6%B8%90%E8%BF%9B%E5%A2%9E%E9%95%BF"><span class="nav-number">2.4.</span> <span class="nav-text">函数的渐进增长</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">2.5.</span> <span class="nav-text">算法时间复杂度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="nav-number">3.</span> <span class="nav-text">线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">3.1.</span> <span class="nav-text">线性表的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.2.</span> <span class="nav-text">线性表的抽象数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">3.3.</span> <span class="nav-text">线性表的顺序存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">3.3.1.</span> <span class="nav-text">顺序存储的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">3.3.2.</span> <span class="nav-text">顺序存储的方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%95%BF%E5%BA%A6%E5%92%8C%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%95%BF%E5%BA%A6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.3.3.</span> <span class="nav-text">数据长度和线性表长度的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95"><span class="nav-number">3.3.4.</span> <span class="nav-text">地址计算方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="nav-number">3.4.</span> <span class="nav-text">顺序存储结构的插入和删除</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%BE%97%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C"><span class="nav-number">3.4.1.</span> <span class="nav-text">获得元素操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="nav-number">3.4.2.</span> <span class="nav-text">插入操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="nav-number">3.4.3.</span> <span class="nav-text">删除操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">3.4.4.</span> <span class="nav-text">线性表顺序存储结构的优缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">3.5.</span> <span class="nav-text">线性表的链式存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-number">3.5.1.</span> <span class="nav-text">顺序存储结构的解决办法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">3.5.2.</span> <span class="nav-text">线性表链式存储结构的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%B4%E6%8C%87%E9%92%88%E5%92%8C%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-number">3.5.3.</span> <span class="nav-text">头指针和头结点的异同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%BB%A3%E7%A0%81%E6%8F%8F%E8%BF%B0"><span class="nav-number">3.5.4.</span> <span class="nav-text">线性表链式存储结构代码描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AA%E4%BA%BA%E5%AF%B9%E6%8C%87%E9%92%88%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">3.5.5.</span> <span class="nav-text">个人对指针的理解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E8%AF%BB%E5%8F%96"><span class="nav-number">3.6.</span> <span class="nav-text">单链表的读取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4"><span class="nav-number">3.7.</span> <span class="nav-text">单链表的插入与删除</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5"><span class="nav-number">3.7.1.</span> <span class="nav-text">单链表的插入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4"><span class="nav-number">3.7.2.</span> <span class="nav-text">单链表的删除</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%95%B4%E8%A1%A8%E5%88%9B%E5%BB%BA"><span class="nav-number">3.8.</span> <span class="nav-text">单链表的整表创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%95%B4%E8%A1%A8%E5%88%A0%E9%99%A4"><span class="nav-number">3.9.</span> <span class="nav-text">单链表的整表删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">3.10.</span> <span class="nav-text">单链表结构与顺序存储结构优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="nav-number">3.11.</span> <span class="nav-text">循环链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-number">3.12.</span> <span class="nav-text">双向链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE-1"><span class="nav-number">3.13.</span> <span class="nav-text">总结回顾</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="nav-number">4.</span> <span class="nav-text">栈与队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">4.1.</span> <span class="nav-text">栈的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89-1"><span class="nav-number">4.1.1.</span> <span class="nav-text">栈的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E6%A0%88%E5%87%BA%E6%A0%88%E5%8F%98%E5%8C%96%E5%BD%A2%E5%BC%8F"><span class="nav-number">4.1.2.</span> <span class="nav-text">进栈出栈变化形式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.2.</span> <span class="nav-text">栈的抽象数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.3.</span> <span class="nav-text">栈的顺序存储结构的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">4.3.1.</span> <span class="nav-text">栈的顺序存储结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E8%BF%9B%E6%A0%88%E6%93%8D%E4%BD%9C"><span class="nav-number">4.3.2.</span> <span class="nav-text">栈的顺序存储结构————进栈操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E5%87%BA%E6%A0%88%E6%93%8D%E4%BD%9C"><span class="nav-number">4.3.3.</span> <span class="nav-text">栈的顺序存储结构————出栈操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E6%A0%88%E5%85%B1%E4%BA%AB%E7%A9%BA%E9%97%B4"><span class="nav-number">4.4.</span> <span class="nav-text">两栈共享空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.5.</span> <span class="nav-text">栈的链式存储结构及实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">4.5.1.</span> <span class="nav-text">栈的链式存储结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E8%BF%9B%E6%A0%88%E6%93%8D%E4%BD%9C"><span class="nav-number">4.5.2.</span> <span class="nav-text">栈的链式存储结构————进栈操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E5%87%BA%E6%A0%88%E6%93%8D%E4%BD%9C"><span class="nav-number">4.5.3.</span> <span class="nav-text">栈的链式存储结构————出栈操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">4.6.</span> <span class="nav-text">栈的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AA%E4%BA%BA%E5%AF%B9%E4%BA%8E%E9%80%92%E5%BD%92%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">4.7.</span> <span class="nav-text">个人对于递归的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">4.8.</span> <span class="nav-text">队列的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="nav-number">4.9.</span> <span class="nav-text">循环队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%9A%84%E4%B8%8D%E8%B6%B3"><span class="nav-number">4.9.1.</span> <span class="nav-text">队列顺序存储的不足</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E5%AE%9A%E4%B9%89"><span class="nav-number">4.9.2.</span> <span class="nav-text">循环队列定义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.10.</span> <span class="nav-text">队列的链式存储结构及实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%85%A5%E9%98%9F%E6%93%8D%E4%BD%9C"><span class="nav-number">4.10.1.</span> <span class="nav-text">队列的链式存储结构——入队操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%87%BA%E9%98%9F%E6%93%8D%E4%BD%9C"><span class="nav-number">4.10.2.</span> <span class="nav-text">队列的链式存储结构——出队操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE-2"><span class="nav-number">4.11.</span> <span class="nav-text">总结回顾</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B2"><span class="nav-number">5.</span> <span class="nav-text">串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">5.1.</span> <span class="nav-text">串的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">5.2.</span> <span class="nav-text">串的比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">5.3.</span> <span class="nav-text">串的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%B2%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">5.3.1.</span> <span class="nav-text">串的顺序存储结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%B2%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">5.3.2.</span> <span class="nav-text">串的链式存储结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE-3"><span class="nav-number">5.4.</span> <span class="nav-text">总结回顾</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">6.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">6.1.</span> <span class="nav-text">树的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E7%82%B9%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-number">6.1.1.</span> <span class="nav-text">结点及相关概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E7%82%B9%E9%97%B4%E5%85%B3%E7%B3%BB"><span class="nav-number">6.1.1.1.</span> <span class="nav-text">结点间关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-number">6.1.1.2.</span> <span class="nav-text">树的其他相关概念</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">6.2.</span> <span class="nav-text">树的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">6.2.1.</span> <span class="nav-text">双亲表示法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">6.2.2.</span> <span class="nav-text">孩子表示法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">6.2.3.</span> <span class="nav-text">孩子兄弟表示法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">6.3.</span> <span class="nav-text">二叉树的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">6.3.1.</span> <span class="nav-text">二叉树的特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">6.3.2.</span> <span class="nav-text">特殊二叉树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-number">6.4.</span> <span class="nav-text">二叉树的性质</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%A7%E8%B4%A81"><span class="nav-number">6.4.1.</span> <span class="nav-text">性质1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%A7%E8%B4%A82"><span class="nav-number">6.4.2.</span> <span class="nav-text">性质2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%A7%E8%B4%A83"><span class="nav-number">6.4.3.</span> <span class="nav-text">性质3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%A7%E8%B4%A84"><span class="nav-number">6.4.4.</span> <span class="nav-text">性质4</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%A7%E8%B4%A85"><span class="nav-number">6.4.5.</span> <span class="nav-text">性质5</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">6.5.</span> <span class="nav-text">二叉树的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">6.5.1.</span> <span class="nav-text">二叉树顺序存储结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8"><span class="nav-number">6.5.2.</span> <span class="nav-text">二叉链表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">6.6.</span> <span class="nav-text">遍历二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%8E%9F%E7%90%86"><span class="nav-number">6.6.1.</span> <span class="nav-text">二叉树的遍历原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95"><span class="nav-number">6.6.2.</span> <span class="nav-text">二叉树遍历方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="nav-number">6.6.3.</span> <span class="nav-text">前序遍历算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="nav-number">6.6.4.</span> <span class="nav-text">中序遍历算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="nav-number">6.6.5.</span> <span class="nav-text">后序遍历算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A8%E5%AF%BC%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C"><span class="nav-number">6.6.6.</span> <span class="nav-text">推导遍历结果</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="nav-number">6.6.7.</span> <span class="nav-text">层序遍历算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="nav-number">6.7.</span> <span class="nav-text">二叉树的建立</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84%E5%BB%BA%E7%AB%8B%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">6.7.1.</span> <span class="nav-text">顺序结构建立二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9E%E5%BC%8F%E7%BB%93%E6%9E%84%E5%BB%BA%E7%AB%8B%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">6.7.2.</span> <span class="nav-text">连式结构建立二叉树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">6.8.</span> <span class="nav-text">线索二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8"><span class="nav-number">6.9.</span> <span class="nav-text">哈夫曼树及其应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="nav-number">6.9.1.</span> <span class="nav-text">哈夫曼树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">6.9.2.</span> <span class="nav-text">构造方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE-4"><span class="nav-number">6.10.</span> <span class="nav-text">总结回顾</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE"><span class="nav-number">7.</span> <span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">7.1.</span> <span class="nav-text">图的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%84%E7%A7%8D%E5%9B%BE%E5%AE%9A%E4%B9%89"><span class="nav-number">7.1.1.</span> <span class="nav-text">各种图定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E9%A1%B6%E7%82%B9%E4%B8%8E%E8%BE%B9%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">7.1.2.</span> <span class="nav-text">图的顶点与边间的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD"><span class="nav-number">7.1.3.</span> <span class="nav-text">连通图相关术语</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%9C%AF%E8%AF%AD%E6%80%BB%E7%BB%93"><span class="nav-number">7.1.4.</span> <span class="nav-text">图的定义与术语总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">7.2.</span> <span class="nav-text">图的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5-%E6%95%B0%E7%BB%84"><span class="nav-number">7.2.1.</span> <span class="nav-text">邻接矩阵(数组)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="nav-number">7.2.2.</span> <span class="nav-text">邻接表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">7.3.</span> <span class="nav-text">图的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-number">7.3.1.</span> <span class="nav-text">深度优先遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-number">7.3.2.</span> <span class="nav-text">广度优先遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">7.4.</span> <span class="nav-text">最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%AE%E9%87%8C%E5%A7%86-Prim-%E7%AE%97%E6%B3%95"><span class="nav-number">7.4.1.</span> <span class="nav-text">普里姆 (Prim) 算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%EF%BC%88Kruskal%EF%BC%89%E7%AE%97%E6%B3%95"><span class="nav-number">7.4.2.</span> <span class="nav-text">克鲁斯卡尔（Kruskal）算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">7.4.3.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">7.5.</span> <span class="nav-text">拓扑排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">7.5.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E8%A1%8C%E6%AD%A5%E9%AA%A4"><span class="nav-number">7.5.2.</span> <span class="nav-text">进行步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E7%AE%97%E6%B3%95%E4%B8%AD%E9%9C%80%E8%A6%81%E7%94%A8%E5%AE%9A%E9%87%8F%E7%9A%84%E6%8F%8F%E8%BF%B0%E6%9B%BF%E4%BB%A3%E5%AE%9A%E6%80%A7%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">7.5.3.</span> <span class="nav-text">在算法中需要用定量的描述替代定性的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="nav-number">7.5.4.</span> <span class="nav-text">拓扑排序算法的描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.5.5.</span> <span class="nav-text">拓扑排序的算法实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="nav-number">7.6.</span> <span class="nav-text">关键路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">7.7.</span> <span class="nav-text">最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E6%BA%90%E7%82%B9%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94Dijkstra%E7%AE%97%E6%B3%95"><span class="nav-number">7.7.1.</span> <span class="nav-text">单源点最短路径问题——Dijkstra算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E9%A1%B6%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E2%80%94%E2%80%94Floyd%E7%AE%97%E6%B3%95"><span class="nav-number">7.7.2.</span> <span class="nav-text">两顶点之间的最短路径——Floyd算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E7%AE%97%E6%B3%95%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-number">7.7.3.</span> <span class="nav-text">两种算法的异同</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE-5"><span class="nav-number">7.8.</span> <span class="nav-text">总结回顾</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE"><span class="nav-number">8.</span> <span class="nav-text">查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="nav-number">8.1.</span> <span class="nav-text">二叉排序树(二叉查找树)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="nav-number">8.1.1.</span> <span class="nav-text">二叉排序树的查找算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-AVL%E6%A0%91"><span class="nav-number">8.2.</span> <span class="nav-text">平衡二叉树(AVL树)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="nav-number">8.2.1.</span> <span class="nav-text">平衡二叉树的定义：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E5%9B%A0%E5%AD%90-balance-factor-%EF%BC%9A"><span class="nav-number">8.2.2.</span> <span class="nav-text">平衡因子 (balance factor)：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E5%8C%96%E6%97%8B%E8%BD%AC"><span class="nav-number">8.2.3.</span> <span class="nav-text">平衡化旋转</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8-Hash"><span class="nav-number">8.3.</span> <span class="nav-text">哈希表(Hash)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">8.3.1.</span> <span class="nav-text">散列表的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">8.3.2.</span> <span class="nav-text">哈希表的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">8.3.3.</span> <span class="nav-text">构造哈希函数的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B9%B3%E6%96%B9%E5%8F%96%E4%B8%AD%E6%B3%95"><span class="nav-number">8.3.3.1.</span> <span class="nav-text">平方取中法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%99%A4%E7%95%99%E4%BD%99%E6%95%B0%E6%B3%95"><span class="nav-number">8.3.3.2.</span> <span class="nav-text">除留余数法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%B3%95"><span class="nav-number">8.3.3.3.</span> <span class="nav-text">随机数法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">8.3.4.</span> <span class="nav-text">处理冲突的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%80%E6%94%BE%E5%AE%9A%E5%9D%80%E6%B3%95-%E9%97%AD%E5%9F%9F%E6%B3%95"><span class="nav-number">8.3.4.1.</span> <span class="nav-text">开放定址法(闭域法)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95-%E5%BC%80%E5%9F%9F%E6%B3%95"><span class="nav-number">8.3.4.2.</span> <span class="nav-text">链地址法(开域法)</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">9.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86"><span class="nav-number">9.1.</span> <span class="nav-text">堆</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">9.1.1.</span> <span class="nav-text">堆的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%BA%E5%A0%86%E3%80%81%E7%AD%9B%E9%80%89"><span class="nav-number">9.1.2.</span> <span class="nav-text">建堆、筛选</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">9.2.</span> <span class="nav-text">插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">9.2.1.</span> <span class="nav-text">直接插入排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%8C%E5%B0%94-Shell-%E6%8E%92%E5%BA%8F"><span class="nav-number">9.2.2.</span> <span class="nav-text">希尔(Shell)排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%9D%E6%83%B3"><span class="nav-number">9.2.2.1.</span> <span class="nav-text">希尔排序的思想</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="nav-number">9.2.2.2.</span> <span class="nav-text">希尔排序的实现方法</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="orion"
      src="/images/suki.jpg">
  <p class="site-author-name" itemprop="name">orion</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/orionGGG" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;orionGGG" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">orion</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
